'From Squeak4.1 of 17 April 2010 [latest update: #9957] on 9 February 2012 at 5:04:35 pm'!ArrayedCollection subclass: #String	instanceVariableNames: ''	classVariableNames: 'AsciiOrder CSLineEnders CSNonSeparators CSSeparators CaseInsensitiveOrder CaseSensitiveOrder HtmlEntities LowercasingTable Tokenish UppercasingTable'	poolDictionaries: ''	category: 'Collections-Strings'!!String commentStamp: '<historical>' prior: 0!A String is an indexed collection of Characters. Class String provides the abstract super class for ByteString (that represents an array of 8-bit Characters) and WideString (that represents an array of  32-bit characters).  In the similar manner of LargeInteger and SmallInteger, those subclasses are chosen accordingly for a string; namely as long as the system can figure out so, the String is used to represent the given string.Strings support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.Here are a few useful methods to look at...	String match:	String contractTo:String also inherits many useful methods from its hierarchy, such as	SequenceableCollection ,	SequenceableCollection copyReplaceAll:with:!!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:30'!byteAt: index	^self subclassResponsibility! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:30'!byteAt: index put: value	^self subclassResponsibility! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:30'!byteSize	^self subclassResponsibility! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!do: aBlock toFieldNumber: aNumber	"Considering the receiver as a holder of tab-delimited fields, evaluate aBlock on behalf of a field in this string"	| start end index |	start := 1.	index := 1.	[start <= self size] whileTrue: 		[end := self indexOf: Character tab startingAt: start ifAbsent: [self size + 1].		end := end - 1.		aNumber = index ifTrue:			[aBlock value: (self copyFrom: start  to: end).			^ self].		index := index + 1.		start := end + 2]"1 to: 6 do:	[:aNumber |		'fred	charlie	elmo		wimpy	friml' do:			[:aField | Transcript cr; show: aField] toFieldNumber: aNumber]"! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!endsWithDigit	"Answer whether the receiver's final character represents a digit.  3/11/96 sw"	^ self size > 0 and: [self last isDigit]! !!String methodsFor: 'accessing' stamp: 'nice 2/26/2010 00:53'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	^delimiters inject: 1 + self size into: [:min :delim |		"delim may be a char, a string of length 1, or a substring"		| ind |		ind := delim isCharacter 			ifTrue: [self indexOf: delim						startingAt: start ifAbsent: [min]]			ifFalse: [self indexOfSubCollection: delim 						startingAt: start ifAbsent: [min]].		min min: ind]! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findBetweenSubStrs: delimiters	"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."	| tokens keyStart keyStop |	tokens := OrderedCollection new.	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipAnySubStr: delimiters startingAt: keyStop.		keyStop := self findAnySubStr: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findCloseParenthesisFor: startIndex	"assume (self at: startIndex) is $(.  Find the matching $), allowing parentheses to nest."	" '(1+(2-3))-3.14159' findCloseParenthesisFor: 1 "	" '(1+(2-3))-3.14159' findCloseParenthesisFor: 4 "	| pos nestLevel |	pos := startIndex+1.	nestLevel := 1.	[ pos <= self size ] whileTrue: [		(self at: pos) = $( ifTrue: [ nestLevel := nestLevel + 1 ].		(self at: pos) = $) ifTrue: [ nestLevel := nestLevel - 1 ].		nestLevel = 0 ifTrue: [ ^pos ].		pos := pos + 1.	].	^self size + 1! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that matches one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1."	start to: self size do: [:i |		delimiters do: [:delim | delim = (self at: i) ifTrue: [^ i]]].	^ self size + 1! !!String methodsFor: 'accessing' stamp: 'nice 10/5/2009 03:15'!findLastOccurrenceOfString: subString startingAt: start 	"Answer the index of the last occurrence of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0.  Case-sensitive match used."	| last now |	last := self findString: subString startingAt: start.	last = 0 ifTrue: [^ 0].	[last > 0] whileTrue:		[now := last.		last := self findString: subString startingAt: last + 1].	^ now! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findString: subString	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^self findString: subString startingAt: 1.! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 23:34'!findString: subString startingAt: start 	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^self findString: subString startingAt: start caseSensitive: true! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 23:33'!findString: key startingAt: start caseSensitive: caseSensitive 	"Answer the index in this String at which the substring key first occurs,	at or beyond start. The match can be case-sensitive or not. If no match	is found, zero will be returned."		"IMPLEMENTATION NOTE: do not use CaseSensitiveOrder because it is broken for WideString	This is a temporary work around until Wide CaseSensitiveOrder search is fixed	Code should revert to:	caseSensitive		ifTrue: [^ self findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]		ifFalse: [^ self findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]"			^caseSensitive		ifTrue: [			(self class isBytes and: [key class isBytes])				ifTrue: [self						findSubstring: key						in: self						startingAt: start						matchTable: CaseSensitiveOrder]				ifFalse: [WideString new						findSubstring: key						in: self						startingAt: start						matchTable: nil]]		ifFalse: [			(self class isBytes and: [key class isBytes])				ifTrue: [self						findSubstring: key						in: self						startingAt: start						matchTable: CaseInsensitiveOrder]				ifFalse: [WideString new						findSubstring: key						in: self						startingAt: start						matchTable: CaseInsensitiveOrder]]! !!String methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:13'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."	| tokens keyStart keyStop separators |	tokens := OrderedCollection new.	separators := delimiters isCharacter 		ifTrue: [Array with: delimiters]		ifFalse: [delimiters].	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipDelimiters: separators startingAt: keyStop.		keyStop := self findDelimiters: separators startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'dtl 8/14/2004 11:27'!findTokens: delimiters escapedBy: quoteDelimiters 	"Answer a collection of Strings separated by the delimiters, where  	delimiters is a Character or collection of characters. Two delimiters in a  	row produce an empty string (compare this to #findTokens, which  	treats sequential delimiters as one).  	 	The characters in quoteDelimiters are treated as quote characters, such  	that any delimiter within a pair of matching quoteDelimiter characters  	is treated literally, rather than as a delimiter.  	 	The quoteDelimiter characters may be escaped within a quoted string.  	Two sequential quote characters within a quoted string are treated as  	a single character.  	 	This method is useful for parsing comma separated variable strings for  	spreadsheet import and export."	| tokens rs activeEscapeCharacter ts char token delimiterChars quoteChars |	delimiterChars := (delimiters isNil				ifTrue: ['']				ifFalse: [delimiters]) asString.	quoteChars := (quoteDelimiters isNil				ifTrue: ['']				ifFalse: [quoteDelimiters]) asString.	tokens := OrderedCollection new.	rs := ReadStream on: self.	activeEscapeCharacter := nil.	ts := WriteStream on: ''.	[rs atEnd]		whileFalse: [char := rs next.			activeEscapeCharacter isNil				ifTrue: [(quoteChars includes: char)						ifTrue: [activeEscapeCharacter := char]						ifFalse: [(delimiterChars includes: char)								ifTrue: [token := ts contents.									tokens add: token.									ts := WriteStream on: '']								ifFalse: [ts nextPut: char]]]				ifFalse: [char == activeEscapeCharacter						ifTrue: [rs peek == activeEscapeCharacter								ifTrue: [ts nextPut: rs next]								ifFalse: [activeEscapeCharacter := nil]]						ifFalse: [ts nextPut: char]]].	token := ts contents.	(tokens isEmpty and: [token isEmpty])		ifFalse: [tokens add: token].	^ tokens! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findTokens: delimiters includes: subString	"Divide self into pieces using delimiters.  Return the piece that includes subString anywhere in it.  Is case sensitive (say asLowercase to everything beforehand to make insensitive)."^ (self findTokens: delimiters) 	detect: [:str | (str includesSubString: subString)] 	ifNone: [nil]! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findTokens: delimiters keep: keepers	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"	| tokens keyStart keyStop |	tokens := OrderedCollection new.	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipDelimiters: delimiters startingAt: keyStop.		keyStop to: keyStart-1 do: [:ii | 			(keepers includes: (self at: ii)) ifTrue: [				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"		keyStop := self findDelimiters: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 23:13'!findWordStart: key startingAt: start	| ind |	"HyperCard style searching.  Answer the index in self of the substring key, when that key is preceeded by a separator character.  Must occur at or beyond start.  The match is case-insensitive.  If no match is found, zero will be returned."	ind := start.	[ind := self findString: key startingAt: ind caseSensitive: false.	ind = 0 ifTrue: [^ 0].	"not found"	ind = 1 ifTrue: [^ 1].	"First char is the start of a word"	(self at: ind-1) isSeparator] whileFalse: [ind := ind + 1].	^ ind	"is a word start"! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!includesSubString: subString	^ (self findString: subString startingAt: 1) > 0! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!includesSubstring: aString caseSensitive: caseSensitive		^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0! !!String methodsFor: 'accessing' stamp: 'yo 8/28/2002 16:45'!indexOf: aCharacter	aCharacter isCharacter ifFalse: [^ 0].	^ self class		indexOfAscii: aCharacter asciiValue		inString: self		startingAt: 1.! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:31'!indexOf: aCharacter startingAt: start	(aCharacter isCharacter) ifFalse: [^ 0].	^ self class indexOfAscii: aCharacter asciiValue inString: self startingAt: start! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:31'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	(aCharacter isCharacter) ifFalse: [ ^ aBlock value ].	ans := self class indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^ aBlock value ]		ifFalse: [ ^ ans ]! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!indexOfSubCollection: sub 	#Collectn.	"Added 2000/04/08 For ANSI <sequenceReadableCollection> protocol."	^ self		indexOfSubCollection: sub		startingAt: 1		ifAbsent: [0]! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 22:58'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	| index |	index := self findString: sub startingAt: start.	index = 0 ifTrue: [^ exceptionBlock value].	^ index! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!lastIndexOfPKSignature: aSignature	"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a := aSignature first.	b := aSignature second.	c := aSignature third.	d := aSignature fourth.	(self size - 3) to: 1 by: -1 do: [ :i |		(((self at: i) = a)			and: [ ((self at: i + 1) = b)				and: [ ((self at: i + 2) = c)					and: [ ((self at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!String methodsFor: 'accessing' stamp: 'yo 12/17/2002 16:56'!leadingCharRunLengthAt: index	| leadingChar |	leadingChar := (self at: index) leadingChar.	index to: self size do: [:i |		(self at: i) leadingChar ~= leadingChar ifTrue: [^ i - index].	].	^ self size - index + 1.! !!String methodsFor: 'accessing' stamp: 'YG 2/9/2012 16:33'!length	"Return the number of characters in the String."	^self size! !!String methodsFor: 'accessing' stamp: 'nice 11/16/2009 12:32'!lineCorrespondingToIndex: anIndex	"Answer a string containing the line at the given character position."	self lineIndicesDo: [:start :endWithoutDelimiters :end |		anIndex <= end ifTrue: [^self copyFrom: start to: endWithoutDelimiters]].	^''! !!String methodsFor: 'accessing' stamp: 'nice 11/16/2009 13:23'!lineCount	"Answer the number of lines represented by the receiver, where every line delimiter CR, LF or CRLF pair adds one line."	| lineCount |	lineCount := 0.	self lineIndicesDo: [:start :endWithoutDelimiters :end |		lineCount := lineCount + 1].	^lineCount! !!String methodsFor: 'accessing' stamp: 'nice 1/19/2010 00:29'!lineIndicesDo: aBlock	"execute aBlock with 3 arguments for each line:	- start index of line	- end index of line without line delimiter	- end index of line including line delimiter(s) CR, LF or CRLF"		| cr lf start sz nextLF nextCR |	start := 1.	sz := self size.	cr := Character cr.	nextCR := self indexOf: cr startingAt: 1.	lf := Character lf.	nextLF := self indexOf: lf startingAt: 1.	[ start <= sz ] whileTrue: [		(nextLF = 0 and: [ nextCR = 0 ])			ifTrue: [ "No more CR, nor LF, the string is over"					aBlock value: start value: sz value: sz.					^self ].		(nextCR = 0 or: [ 0 < nextLF and: [ nextLF < nextCR ] ])			ifTrue: [ "Found a LF"					aBlock value: start value: nextLF - 1 value: nextLF.					start := 1 + nextLF.					nextLF := self indexOf: lf startingAt: start ]			ifFalse: [ 1 + nextCR = nextLF				ifTrue: [ "Found a CR-LF pair"					aBlock value: start value: nextCR - 1 value: nextLF.					start := 1 + nextLF.					nextCR := self indexOf: cr startingAt: start.					nextLF := self indexOf: lf startingAt: start ]				ifFalse: [ "Found a CR"					aBlock value: start value: nextCR - 1 value: nextCR.					start := 1 + nextCR.					nextCR := self indexOf: cr startingAt: start ]]]! !!String methodsFor: 'accessing' stamp: 'nice 11/16/2009 13:23'!lineNumber: anIndex	"Answer a string containing the characters in the given line number."	| lineCount |	lineCount := 0.	self lineIndicesDo: [:start :endWithoutDelimiters :end |		(lineCount := lineCount + 1) = anIndex ifTrue: [^self copyFrom: start to: endWithoutDelimiters]].	^nil! !!String methodsFor: 'accessing' stamp: 'nice 11/16/2009 12:26'!linesDo: aBlock	"Execute aBlock with each line in this string. The terminating line delimiters CR, LF or CRLF pairs are not included in what is passed to aBlock"	self lineIndicesDo: [:start :endWithoutDelimiters :end |		aBlock value: (self copyFrom: start to: endWithoutDelimiters)]! !!String methodsFor: 'accessing' stamp: 'yo 8/28/2002 14:28'!skipAnySubStr: delimiters startingAt: start 	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."	| any this ind ii |	ii := start-1.	[(ii := ii + 1) <= self size] whileTrue: [ "look for char that does not match"		any := false.		delimiters do: [:delim |			delim isCharacter 				ifTrue: [(self at: ii) == delim ifTrue: [any := true]]				ifFalse: ["a substring"					delim size > (self size - ii + 1) ifFalse: "Here's where the one-off error was."						[ind := 0.						this := true.						delim do: [:dd | 							dd == (self at: ii+ind) ifFalse: [this := false].							ind := ind + 1].						this ifTrue: [ii := ii + delim size - 1.  any := true]]							ifTrue: [any := false] "if the delim is too big, it can't match"]].		any ifFalse: [^ ii]].	^ self size + 1! !!String methodsFor: 'accessing' stamp: 'ul 12/7/2009 06:41'!skipDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string."	start to: self size do: [:i |		(delimiters includes: (self at: i)) ifFalse: [ ^i ] ].	^self size + 1! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!startsWithDigit	"Answer whether the receiver's first character represents a digit"	^ self size > 0 and: [self first isDigit]! !!String methodsFor: 'accessing' stamp: 'md 5/26/2005 13:35'!string	^self! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!tabDelimitedFieldsDo: aBlock	"Considering the receiver as a holder of tab-delimited fields, evaluate execute aBlock with each field in this string.  The separatilng tabs are not included in what is passed to aBlock"	| start end |	"No senders but was useful enough in earlier work that it's retained for the moment."	start := 1.	[start <= self size] whileTrue: 		[end := self indexOf: Character tab startingAt: start ifAbsent: [self size + 1].		end := end - 1.		aBlock value: (self copyFrom: start  to: end).		start := end + 2]"'fred	charlie	elmo		2' tabDelimitedFieldsDo: [:aField | Transcript cr; show: aField]"! !!String methodsFor: 'arithmetic' stamp: 'yo 11/3/2004 19:24'!* arg	^ arg adaptToString: self andSend: #*! !!String methodsFor: 'arithmetic' stamp: 'yo 11/3/2004 19:24'!+ arg	^ arg adaptToString: self andSend: #+! !!String methodsFor: 'arithmetic' stamp: 'yo 11/3/2004 19:24'!- arg	^ arg adaptToString: self andSend: #-! !!String methodsFor: 'arithmetic' stamp: 'yo 11/3/2004 19:24'!/ arg	^ arg adaptToString: self andSend: #/! !!String methodsFor: 'arithmetic' stamp: 'yo 11/3/2004 19:24'!// arg	^ arg adaptToString: self andSend: #//! !!String methodsFor: 'arithmetic' stamp: 'yo 11/3/2004 19:24'!\\ arg	^ arg adaptToString: self andSend: #\\! !!String methodsFor: 'comparing' stamp: 'lr 7/7/2006 11:19'!< aString 	"Answer whether the receiver sorts before aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) = 1! !!String methodsFor: 'comparing' stamp: 'lr 7/7/2006 11:20'!<= aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is simple ascii (with case differences)."		^ (self compare: self with: aString collated: AsciiOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'lr 7/7/2006 11:21'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."		aString isString ifFalse: [ ^ false ].	^ (self compare: self with: aString collated: AsciiOrder) = 2! !!String methodsFor: 'comparing' stamp: 'lr 7/7/2006 11:21'!> aString 	"Answer whether the receiver sorts after aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) = 3! !!String methodsFor: 'comparing' stamp: 'lr 7/7/2006 11:21'!>= aString 	"Answer whether the receiver sorts after or equal to aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) >= 2! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!alike: aString 	"Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score.  Case is ignored."	| i j k minSize bonus |	minSize := (j := self size) min: (k := aString size).	bonus := (j - k) abs < 2 ifTrue: [ 1 ] ifFalse: [ 0 ].	i := 1.	[(i <= minSize) and: [((super at: i) bitAnd: 16rDF)  = ((aString at: i) asciiValue bitAnd: 16rDF)]]		whileTrue: [ i := i + 1 ].	[(j > 0) and: [(k > 0) and:		[((super at: j) bitAnd: 16rDF) = ((aString at: k) asciiValue bitAnd: 16rDF)]]]			whileTrue: [ j := j - 1.  k := k - 1. ].	^ i - 1 + self size - j + bonus. ! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:39'!caseInsensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case insensitive."	^(self compare: aString caseSensitive: false) <= 2! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:39'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	^(self compare: aString caseSensitive: true) <= 2! !!String methodsFor: 'comparing' stamp: 'yo 8/27/2002 14:15'!charactersExactlyMatching: aString	"Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."	| count |	count := self size min: aString size.	1 to: count do: [:i | 		(self at: i) = (aString at: i) ifFalse: [			^ i - 1]].	^ count! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:38'!compare: aString 	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	The collation sequence is ascii with case differences ignored.	To get the effect of a <= b, but ignoring case, use (a compare: b) <= 2."	^self compare: aString caseSensitive: false! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:42'!compare: aString caseSensitive: aBool	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	"	| map |	map := aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder].	^self compare: self with: aString collated: map! !!String methodsFor: 'comparing' stamp: 'yo 12/15/2005 14:28'!compare: string1 with: string2 collated: order	(string1 isByteString and: [string2 isByteString]) ifTrue: [		^ ByteString compare: string1 with: string2 collated: order	].     "Primitive does not fail properly right now"      ^ String compare: string1 with: string2 collated: order"self assert: 'abc' = 'abc' asWideString.self assert: 'abc' asWideString = 'abc'.self assert: ((ByteArray with: 97 with: 0 with: 0 with: 0) asString ~= 'a000' asWideString).self assert: ('a000' asWideString ~= (ByteArray with: 97 with: 0 with: 0 with: 0) asString).self assert: ('abc' sameAs: 'aBc' asWideString).self assert: ('aBc' asWideString sameAs: 'abc').self assert: ((ByteArray with: 97 with: 0 with: 0 with: 0) asString sameAs: 'Abcd' asWideString) not.self assert: ('a000' asWideString sameAs: (ByteArray with: 97 with: 0 with: 0 with: 0) asString) not."! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 17:27'!crc16	"Compute a 16 bit cyclic redundancy check."	| crc |	crc := 0.	1 to: self byteSize do: [:i |		crc := (crc bitShift: -8) bitXor: (		 #(	16r0000	16rC0C1	16rC181	16r0140	16rC301	16r03C0	16r0280	16rC241			16rC601	16r06C0	16r0780	16rC741	16r0500	16rC5C1	16rC481	16r0440			16rCC01	16r0CC0	16r0D80	16rCD41	16r0F00	16rCFC1	16rCE81	16r0E40			16r0A00	16rCAC1	16rCB81	16r0B40	16rC901	16r09C0	16r0880	16rC841			16rD801	16r18C0	16r1980	16rD941	16r1B00	16rDBC1	16rDA81	16r1A40			16r1E00	16rDEC1	16rDF81	16r1F40	16rDD01	16r1DC0	16r1C80	16rDC41			16r1400	16rD4C1	16rD581	16r1540	16rD701	16r17C0	16r1680	16rD641			16rD201	16r12C0	16r1380	16rD341	16r1100	16rD1C1	16rD081	16r1040			16rF001	16r30C0	16r3180	16rF141	16r3300	16rF3C1	16rF281	16r3240			16r3600	16rF6C1	16rF781	16r3740	16rF501	16r35C0	16r3480	16rF441			16r3C00	16rFCC1	16rFD81	16r3D40	16rFF01	16r3FC0	16r3E80	16rFE41			16rFA01	16r3AC0	16r3B80	16rFB41	16r3900	16rF9C1	16rF881	16r3840			16r2800	16rE8C1	16rE981	16r2940	16rEB01	16r2BC0	16r2A80	16rEA41			16rEE01	16r2EC0	16r2F80	16rEF41	16r2D00	16rEDC1	16rEC81	16r2C40			16rE401	16r24C0	16r2580	16rE541	16r2700	16rE7C1	16rE681	16r2640			16r2200	16rE2C1	16rE381	16r2340	16rE101	16r21C0	16r2080	16rE041			16rA001	16r60C0	16r6180	16rA141	16r6300	16rA3C1	16rA281	16r6240			16r6600	16rA6C1	16rA781	16r6740	16rA501	16r65C0	16r6480	16rA441			16r6C00	16rACC1	16rAD81	16r6D40	16rAF01	16r6FC0	16r6E80	16rAE41			16rAA01	16r6AC0	16r6B80	16rAB41	16r6900	16rA9C1	16rA881	16r6840			16r7800	16rB8C1	16rB981	16r7940	16rBB01	16r7BC0	16r7A80	16rBA41			16rBE01	16r7EC0	16r7F80	16rBF41	16r7D00	16rBDC1	16rBC81	16r7C40			16rB401	16r74C0	16r7580	16rB541	16r7700	16rB7C1	16rB681	16r7640			16r7200	16rB2C1	16rB381	16r7340	16rB101	16r71C0	16r7080	16rB041			16r5000	16r90C1	16r9181	16r5140	16r9301	16r53C0	16r5280	16r9241			16r9601	16r56C0	16r5780	16r9741	16r5500	16r95C1	16r9481	16r5440			16r9C01	16r5CC0	16r5D80	16r9D41	16r5F00	16r9FC1	16r9E81	16r5E40			16r5A00	16r9AC1	16r9B81	16r5B40	16r9901	16r59C0	16r5880	16r9841			16r8801	16r48C0	16r4980	16r8941	16r4B00	16r8BC1	16r8A81	16r4A40			16r4E00	16r8EC1	16r8F81	16r4F40	16r8D01	16r4DC0	16r4C80	16r8C41			16r4400	16r84C1	16r8581	16r4540	16r8701	16r47C0	16r4680	16r8641			16r8201	16r42C0	16r4380	16r8341	16r4100	16r81C1	16r8081	16r4040)			 at: ((crc bitXor: (self byteAt: i)) bitAnd: 16rFF) + 1) ].	^crc! !!String methodsFor: 'comparing' stamp: 'nice 7/27/2007 22:55'!endsWith: suffix	"Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive."		| extra |	(extra := self size - suffix size) < 0 ifTrue: [^ false].	^ (self findString: suffix startingAt: extra + 1) > 0"  'Elvis' endsWith: 'vis'"! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!endsWithAnyOf: aCollection	aCollection do:[:suffix|		(self endsWith: suffix) ifTrue:[^true].	].	^false! !!String methodsFor: 'comparing' stamp: 'md 2/16/2006 17:49'!hash	"#hash is implemented, because #= is implemented"	"ar 4/10/2005: I had to change this to use ByteString hash as initial 	hash in order to avoid having to rehash everything and yet compute	the same hash for ByteString and WideString.	md 16/10/2006: use identityHash as initialHash, as behavior hash will     use String hash (name) to have a better hash soon"	^ self class stringHash: self initialHash: ByteString identityHash! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!hashMappedBy: map	"My hash is independent of my oop."	^self hash! !!String methodsFor: 'comparing' stamp: 'ul 11/2/2009 03:01'!hashWithInitialHash: initialHash		^ self class stringHash: self initialHash: initialHash! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!howManyMatch: string 	"Count the number of characters that match up in self and aString."	| count shorterLength |		count  :=  0 .	shorterLength  :=  ((self size ) min: (string size ) ) .	(1 to: shorterLength  do: [:index |		 (((self at: index ) = (string at: index )  ) ifTrue: [count  :=  (count + 1 ) .			]   ).		]   ).	^  count 		! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!match: text	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	^ self startingAt: 1 match: text startingAt: 1"	'*'			match: 'zort' true	'*baz'		match: 'mobaz' true	'*baz'		match: 'mobazo' false	'*baz*'		match: 'mobazo' true	'*baz*'		match: 'mozo' false	'foo*'		match: 'foozo' true	'foo*'		match: 'bozo' false	'foo*baz'	match: 'foo23baz' true	'foo*baz'	match: 'foobaz' true	'foo*baz'	match: 'foo23bazo' false	'foo'		match: 'Foo' true	'foo*baz*zort' match: 'foobazort' false	'foo*baz*zort' match: 'foobazzort' false	'*foo#zort'	match: 'afoo3zortthenfoo3zort' true	'*foo*zort'	match: 'afoodezortorfoo3zort' true"! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 17:35'!sameAs: aString 	"Answer whether the receiver sorts equal to aString. The 	collation sequence is ascii with case differences ignored."	^(self compare: aString caseSensitive: false) = 2! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	| anyMatch matchStart matchEnd i matchStr j ii jj |	i := keyStart.	j := textStart.	"Check for any #'s"	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].	(self at: i) = $#] whileTrue:		["# consumes one char of key and one char of text"		j > text size ifTrue: [^ false "no more text"].		i := i+1.  j := j+1].	"Then check for *"	(self at: i) = $*		ifTrue: [i = self size ifTrue:					[^ true "Terminal * matches all"].				"* means next match string can occur anywhere"				anyMatch := true.				matchStart := i + 1]		ifFalse: ["Otherwise match string must occur immediately"				anyMatch := false.				matchStart := i].	"Now determine the match string"	matchEnd := self size.	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '** not valid -- use * instead'].		matchEnd := ii-1].	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '*# not valid -- use #* instead'].		matchEnd := matchEnd min: ii-1].	matchStr := self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj := text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j := j+1].	^ false "Failed to find the match string"! !!String methodsFor: 'converting' stamp: 'ar 12/27/2009 14:56'!, anObject	"Concatenate the argument to the receiver.		Transcript cr; show: 'The value is: ', 3.	"	^ self copyReplaceFrom: self size + 1		  to: self size		  with: anObject asString! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a collection, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a number, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a point, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a string, convert us both to	numbers, and return the printString of the result."	^ (rcvr asNumber perform: selector with: self asNumber) printString! !!String methodsFor: 'converting' stamp: 'mw 1/30/2004 11:53'!asAlphaNumeric: totalSize extraChars: additionallyAllowed mergeUID: minimalSizeOfRandomPart	"Generates a String with unique identifier ( UID ) qualities, the difference to a	 UUID is that its beginning is derived from the receiver, so that it has a meaning	 for a human reader.	 Answers a String of totalSize, which consists of 3 parts	 1.part: the beginning of the receiver only consisting of		a-z, A-Z, 0-9 and extraChars in Collection additionallyAllowed ( which can be nil )	 2.part: a single _	 3.part: a ( random ) UID of size >= minimalSizeOfRandomPart consisting of		a-z, A-Z, 0-9	 Starting letters are capitalized. 	 TotalSize must be at least 1.	 Exactly 1 occurrence of $_ is guaranteed ( unless additionallyAllowed includes $_ ).	 The random part has even for small sizes good UID qualitites for many practical purposes.	 If only lower- or uppercase letters are demanded, simply convert the answer with	 say #asLowercase. The probability of a duplicate will rise only moderately ( see below ).	 Example: 		size of random part = 10		in n generated UIDs the chance p of having non-unique UIDs is			n = 10000 ->  p < 1e-10		if answer is reduced to lowerCase: p < 1.4 e-8			n = 100000 -> p < 1e-8		at the bottom is a snippet for your own calculations  		Note: the calculated propabilites are theoretical,			for the actually used random generator they may be much worse"	| stream out sizeOfFirstPart index ascii ch skip array random |	totalSize > minimalSizeOfRandomPart 		ifFalse: [ self errorOutOfBounds ].	stream := ReadStream on: self.	out := WriteStream on: ( String new: totalSize ).	index := 0.	skip := true.	sizeOfFirstPart := totalSize - minimalSizeOfRandomPart - 1.	[ stream atEnd or: [ index >= sizeOfFirstPart ]]	whileFalse: [		((( ascii := ( ch := stream next ) asciiValue ) >= 65 and: [ ascii <= 90 ]) or: [			( ascii >= 97 and: [ ascii <= 122 ]) or: [			 			ch isDigit or: [			additionallyAllowed notNil and: [ additionallyAllowed includes: ch ]]]])		ifTrue: [			skip				ifTrue: [ out nextPut: ch asUppercase ]				ifFalse: [ out nextPut: ch ].			index := index + 1.			skip := false ]		ifFalse: [ skip := true ]].	out nextPut: $_.	array := Array new: 62.	1 to: 26 do: [ :i |		array at: i put: ( i + 64 ) asCharacter.		array at: i + 26 put: ( i + 96 ) asCharacter ].	53 to: 62 do: [ :i |		array at: i put: ( i - 5 ) asCharacter ].	random := UUIDGenerator default randomGenerator. 	totalSize - index - 1 timesRepeat: [		out nextPut: ( array atRandom: random )].	^out contents	"	calculation of probability p for failure of uniqueness in n UIDs		Note: if answer will be converted to upper or lower case replace 62 with 36	| n i p all |	all := 62 raisedTo: sizeOfRandomPart.	i := 1.	p := 0.0 .	n := 10000.	[ i <= n ]	whileTrue: [		p := p + (( i - 1 ) / all ).		i := i + 1 ].	p   	approximation formula: n squared / ( 62.0 raisedTo: sizeOfRandomPart ) / 2 	" 	"'Crop SketchMorphs and Grab Screen Rect to JPG' 			asAlphaNumeric: 31 extraChars: nil mergeUID: 10  	 			'CropSketchMorphsAndG_iOw94jquN6'	 'Monticello' 			asAlphaNumeric: 31 extraChars: nil mergeUID: 10    				'Monticello_kp6aV2l0IZK9uBULGOeG' 	 'version-', ( '1.1.2' replaceAll: $. with: $- )			asAlphaNumeric: 31 extraChars: #( $- ) mergeUID: 10    				'Version-1-1-2_kuz2tMg2xX9iRLDVR'"		! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 17:18'!asByteArray	"Convert to a ByteArray with the ascii values of the string."	| b |	b := ByteArray new: self byteSize.	1 to: self size * 4 do: [:i |		b at: i put: (self byteAt: i).	].	^ b.! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 16:22'!asByteString	"Convert the receiver into a ByteString"	^self asOctetString! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 17:03'!asCharacter	"Answer the receiver's first character, or '*' if none.  Idiosyncratic, provisional."	^ self size > 0 ifTrue: [self first] ifFalse:[$·]! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asDate	"Many allowed forms, see Date>>#readFrom:"	^ Date fromString: self! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asDateAndTime

	"Convert from UTC format" 	^ DateAndTime fromString: self! !!String methodsFor: 'converting' stamp: 'ar 8/27/2009 20:41'!asDecomposedUnicode	"Convert the receiver into a decomposed Unicode representation.	Optimized for the common case that no decomposition needs to take place."	| lastIndex nextIndex out decomposed |	lastIndex := 1.	nextIndex := 0.	[(nextIndex := nextIndex+1) <= self size] whileTrue:[		decomposed := Unicode decompose: (self at: nextIndex).		decomposed ifNotNil:[			lastIndex = 1 ifTrue:[out := WriteStream on: (String new: self size)].			out nextPutAll: (self copyFrom: lastIndex to: nextIndex-1).			out nextPutAll: decomposed.			lastIndex := nextIndex+1.		].	].	^out ifNil:[self] ifNotNil:[		out nextPutAll: (self copyFrom: lastIndex to: self size).		out contents]! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asDisplayText	"Answer a DisplayText whose text string is the receiver."	^DisplayText text: self asText! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asDuration
	"convert from [nnnd]hh:mm:ss[.nanos] format. [] implies optional elements"

	^ Duration fromString: self
! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 13:55'!asFileName	"Answer a String made up from the receiver that is an acceptable file 	name."	| string checkedString |	string := FileDirectory checkName: self fixErrors: true.	checkedString := (FilePath pathName: string) asVmPathName.	^ (FilePath pathName: checkedString isEncoded: true) asSqueakPathName.! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:38'!asFourCode	| result |	self size = 4 ifFalse: [^self error: 'must be exactly four characters'].	result := self inject: 0 into: [:val :each | 256 * val + each asciiValue].	(result bitAnd: 16r80000000) = 0 		ifFalse: [self error: 'cannot resolve fourcode'].	(result bitAnd: 16r40000000) = 0 ifFalse: [^result - 16r80000000].	^ result! !!String methodsFor: 'converting' stamp: 'yo 8/26/2002 23:06'!asHex	| stream |	stream := WriteStream on: (String new: self size * 4).	self do: [ :ch | stream nextPutAll: ch hex ].	^stream contents! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asHtml	"Do the basic character conversion for HTML.  Leave all original return 	and tabs in place, so can conver back by simply removing bracked 	things. 4/4/96 tk"	| temp |	temp := self copyReplaceAll: '&' with: '&amp;'.	HtmlEntities keysAndValuesDo:		[:entity :char |		char = $& ifFalse:			[temp := temp copyReplaceAll: char asString with: '&' , entity , ';']].	temp := temp copyReplaceAll: '	' with: '	<IMG SRC="tab.gif" ALT="    ">'.	temp := temp copyReplaceAll: '' with: '<BR>'.	^ temp"	'A<&>B' asHtml"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asIdentifier: shouldBeCapitalized	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"	| aString firstChar firstLetterPosition |	aString := self select: [:el | el isAlphaNumeric].	firstLetterPosition := aString findFirst: [:ch | ch isLetter].	aString := firstLetterPosition == 0		ifFalse:			[aString copyFrom: firstLetterPosition to: aString size]		ifTrue:			['a', aString].	firstChar := shouldBeCapitalized ifTrue: [aString first asUppercase] ifFalse: [aString first asLowercase].	^ firstChar asString, (aString copyFrom: 2 to: aString size)"'234Fred987' asIdentifier: false'235Fred987' asIdentifier: true'' asIdentifier: true'()87234' asIdentifier: false'())z>=PPve889  U >' asIdentifier: false"! !!String methodsFor: 'converting' stamp: 'laza 10/1/2004 09:55'!asInteger 	^self asSignedInteger! !!String methodsFor: 'converting' stamp: 'nice 3/12/2010 23:18'!asLegalSelector	| toUse |	toUse := self select: [:char | char isAlphaNumeric].	(toUse size = 0 or: [toUse first isLetter not])		ifTrue: [toUse := 'v', toUse].	^ toUse withFirstCharacterDownshifted! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase."	^ self copy asString translateToLowercase! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asNumber 	"Answer the Number created by interpreting the receiver as the string 	representation of a number."	^Number readFromString: self! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 20:55'!asOctetString	"Convert the receiver into an octet string"	| string |	string := String new: self size.	1 to: self size do: [:i | string at: i put: (self at: i)].	^string! !!String methodsFor: 'converting' stamp: 'nice 12/26/2009 01:02'!asPacked	"Convert to a longinteger that describes the string"	^ self inject: 0 into: [ :pack :next | pack * 256 + next asInteger ].! !!String methodsFor: 'converting' stamp: 'dew 9/13/2001 01:17'!asPluralBasedOn: aNumberOrCollection	"Append an 's' to this string based on whether aNumberOrCollection is 1 or of size 1."	^ (aNumberOrCollection = 1 or:		[aNumberOrCollection isCollection and: [aNumberOrCollection size = 1]])			ifTrue: [self]			ifFalse: [self, 's']! !!String methodsFor: 'converting' stamp: 'ar 8/27/2009 20:41'!asPrecomposedUnicode	"Convert the receiver into a precomposed Unicode representation.	Optimized for the common case that no composition needs to take place."	| lastIndex nextIndex composed out |	lastIndex := 1.	nextIndex := 0.	[(nextIndex := nextIndex+1) < self size] whileTrue:[		composed := Unicode compose: (self at: nextIndex) with: (self at: nextIndex+1).		composed ifNotNil:[			lastIndex = 1 ifTrue:[out := WriteStream on: (String new: self size)].			out nextPutAll: (self copyFrom: lastIndex to: nextIndex-1).			out nextPut: composed.			nextIndex := nextIndex+1.			lastIndex := nextIndex+1.		].	].	^out ifNil:[self] ifNotNil:[		out nextPutAll: (self copyFrom: lastIndex to: self size).		out contents]! !!String methodsFor: 'converting' stamp: 'nice 12/9/2009 12:38'!asSignedInteger	"Returns the first signed integer it can find or nil."	| start |	start := self findFirst: [:char | char isDigit].	start isZero ifTrue: [^ nil].	(start > 1 and: [self at: start - 1]) = $- ifTrue: [start := start - 1].	^ Integer readFrom: (ReadStream on: self from: start to: self size)! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asSmalltalkComment	"return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled"	^String streamContents:  [ :str |		| quoteCount first |		str nextPut: $".			quoteCount := 0.		first := true.		self do: [ :char |			char = $"				ifTrue: [					first ifFalse: [						str nextPut: char.						quoteCount := quoteCount + 1 ] ]				ifFalse: [					quoteCount odd ifTrue: [						"add a quote to even the number of quotes in a row"						str nextPut: $" ].					quoteCount := 0.					str nextPut: char ].			first := false ]. 		quoteCount odd ifTrue: [			"check at the end"			str nextPut: $". ].		str nextPut: $".	].	! !!String methodsFor: 'converting' stamp: 'yo 12/19/2003 21:16'!asSqueakPathName	^ self.! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asString	"Answer this string."	^ self! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asStringOrText	"Answer this string."	^ self! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 19:24'!asSymbol	"Answer the unique Symbol whose characters are the characters of the 	string."	^Symbol intern: self! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asText	"Answer a Text whose string is the receiver."	^Text fromString: self! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asTime	"Many allowed forms, see Time>>readFrom:"	^ Time fromString: self.! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asTimeStamp	"Convert from obsolete TimeStamp format"
	^ TimeStamp fromString: self! !!String methodsFor: 'converting' stamp: 'tfel 8/28/2009 21:15'!asUnHtml	"Strip out all Html stuff (commands in angle brackets <>) and convertthe characters &<> back to their real value.  Leave actual cr and tab asthey were in text."	| in out char rest |	in := ReadStream on: self.	out := WriteStream on: (String new: self size).	[in atEnd] whileFalse:		[in peek = $<			ifTrue: [in unCommand] 	"Absorb <...><...>"			ifFalse: [(char := in next) = $&						ifTrue: [rest := in upTo: $;.								out nextPut: (HtmlEntities									at: rest									ifAbsent: [Character space])]						ifFalse: [out nextPut: char]].		].	^ out contents! !!String methodsFor: 'converting' stamp: 'laza 10/1/2004 10:02'!asUnsignedInteger 	"Returns the first integer it can find or nil."	| start stream |	start := self findFirst: [:char | char isDigit].	start isZero ifTrue: [^nil].	stream := (ReadStream on: self) position: start - 1.	^Integer readFrom: stream! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asUppercase	"Answer a String made up from the receiver whose characters are all 	uppercase."	^self copy asString translateToUppercase! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asUrl	"convert to a Url"	"'http://www.cc.gatech.edu/' asUrl"	"msw://chaos.resnet.gatech.edu:9000/' asUrl"	^Url absoluteFromText: self! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asUrlRelativeTo: aUrl	^aUrl newFromRelativeText: self! !!String methodsFor: 'converting' stamp: 'yo 2/24/2005 18:33'!asVmPathName	^ (FilePath pathName: self) asVmPathName.! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!askIfAddStyle: priorMethod req: requestor	^ self   "we are a string with no text style"! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 17:36'!asWideString 	self isWideString		ifTrue:[^self]		ifFalse:[^WideString from: self]! !!String methodsFor: 'converting' stamp: 'ar 7/22/2009 22:00'!base64Decoded	"Decode the receiver from base 64"	"'SGVsbG8gV29ybGQ=' base64Decoded"	^(Base64MimeConverter mimeDecode: self as: self class)! !!String methodsFor: 'converting' stamp: 'ar 7/22/2009 22:00'!base64Encoded	"Encode the receiver as base64"	"'Hello World' base64Encoded"	^(Base64MimeConverter mimeEncode: (ReadStream on: self)) contents! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap := self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting' stamp: 'nice 12/26/2009 22:13'!compressWithTable: tokens	"Return a string with all substrings that occur in tokens replaced	by a character with ascii code = 127 + token index.	This will work best if tokens are sorted by size.	Assumes this string contains no characters > 127, or that they	are intentionally there and will not interfere with this process."	| str null finalSize result ri c |	null := Character value: 0.	str := self copyFrom: 1 to: self size.  "Working string will get altered"	finalSize := str size.	tokens doWithIndex:		[:token :tIndex |		| start ts |		start := 1.		[(start := str findString: token startingAt: start) > 0]			whileTrue:			[ts := token size.			((start + ts) <= str size				and: [(str at: start + ts) = $  and: [tIndex*2 <= 128]])				ifTrue: [ts := token size + 1.  "include training blank"						str at: start put: (Character value: tIndex*2 + 127)]				ifFalse: [str at: start put: (Character value: tIndex + 127)].			str at: start put: (Character value: tIndex + 127).			1 to: ts-1 do: [:i | str at: start+i put: null].			finalSize := finalSize - (ts - 1).			start := start + ts]].	result := String new: finalSize.	ri := 0.	1 to: str size do:		[:i | (c := str at: i) = null ifFalse: [result at: (ri := ri+1) put: c]].	^ result! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!contractTo: smallSize	"return myself or a copy shortened by ellipsis to smallSize"	| leftSize |	self size <= smallSize		ifTrue: [^ self].  "short enough"	smallSize < 5		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"	leftSize := smallSize-2//2.	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"		to: self size - (smallSize - leftSize - 3)		with: '...'"	'A clear but rather long-winded summary' contractTo: 18"! !!String methodsFor: 'converting' stamp: 'KR 1/30/2006 21:47'!convertFromEncoding: encodingName	^self convertFromWithConverter: (TextConverter newForEncoding: encodingName)! !!String methodsFor: 'converting' stamp: 'KR 1/30/2006 21:47'!convertFromSuperSwikiServerString	^self convertFromEncoding: 'shift_jis'! !!String methodsFor: 'converting' stamp: 'ul 3/13/2010 19:43'!convertFromWithConverter: converter	^(converter ifNil: [ ^self]) decodeString: self! !!String methodsFor: 'converting' stamp: 'KR 1/30/2006 21:49'!convertToEncoding: encodingName	^self convertToWithConverter: (TextConverter newForEncoding: encodingName).! !!String methodsFor: 'converting' stamp: 'KR 1/30/2006 21:50'!convertToSuperSwikiServerString	^self convertToEncoding: 'shift_jis'! !!String methodsFor: 'converting' stamp: 'nice 11/22/2009 21:06'!convertToSystemString	^self convertToWithConverter: LanguageEnvironment defaultSystemConverter! !!String methodsFor: 'converting' stamp: 'ul 3/13/2010 19:43'!convertToWithConverter: converter 	^(converter ifNil: [ ^self]) encodeString: self! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!correctAgainst: wordList	"Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:"	| results |	results := self correctAgainst: wordList continuedFrom: nil.	results := self correctAgainst: nil continuedFrom: results.	^ results! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!correctAgainst: wordList continuedFrom: oldCollection	"Like correctAgainst:.  Use when you want to correct against several lists, give nil as the first oldCollection, and nil as the last wordList."	^ wordList isNil		ifTrue: [ self correctAgainstEnumerator: nil					continuedFrom: oldCollection ]		ifFalse: [ self correctAgainstEnumerator: [ :action | wordList do: action without: nil]					continuedFrom: oldCollection ]! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!correctAgainstDictionary: wordDict continuedFrom: oldCollection	"Like correctAgainst:continuedFrom:.  Use when you want to correct against a dictionary."	^ wordDict isNil		ifTrue: [ self correctAgainstEnumerator: nil					continuedFrom: oldCollection ]		ifFalse: [ self correctAgainstEnumerator: [ :action | wordDict keysDo: action ]					continuedFrom: oldCollection ]! !!String methodsFor: 'converting' stamp: 'yo 7/29/2005 16:04'!encodeForHTTP	"change dangerous characters to their %XX form, for use in HTTP transactions"	^ self encodeForHTTPWithTextEncoding: 'utf-8' conditionBlock: [:c | c isSafeForHTTP].! !!String methodsFor: 'converting' stamp: 'yo 7/29/2005 16:04'!encodeForHTTPWithTextEncoding: encodingName	^ self encodeForHTTPWithTextEncoding: encodingName conditionBlock: [:c | c isSafeForHTTP].! !!String methodsFor: 'converting' stamp: 'nice 12/27/2009 03:10'!encodeForHTTPWithTextEncoding: encodingName conditionBlock: conditionBlock	"change dangerous characters to their %XX form, for use in HTTP transactions"	| httpSafeStream encodedStream |	httpSafeStream := WriteStream on: (String new).	encodedStream := MultiByteBinaryOrTextStream on: (String new: 6).	encodedStream converter: (TextConverter newForEncoding: encodingName).	self do: [:c | | cont |		(conditionBlock value: c)			ifTrue: [httpSafeStream nextPut: (Character value: c charCode)]			ifFalse: [				encodedStream text; resetToStart.				encodedStream nextPut: c.				encodedStream position: 0.				encodedStream binary.				cont := encodedStream contents.				cont do: [:byte |					httpSafeStream nextPut: $%.					httpSafeStream nextPut: (byte // 16) asHexDigit.					httpSafeStream nextPut: (byte \\ 16) asHexDigit.				].			].	].	^ httpSafeStream contents.! !!String methodsFor: 'converting' stamp: 'nice 12/27/2009 04:54'!findSelector	"Dan's code for hunting down selectors with keyword parts; while this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it."	| sel possibleParens |	sel := self withBlanksTrimmed.	(sel includes: $:) ifTrue:		[sel := sel copyReplaceAll: ':' with: ': '.	"for the style (aa max:bb) with no space"		possibleParens := sel findTokens: Character separators.		sel := self class streamContents:			[:s | | level |			 level := 0.			possibleParens do:				[:token | | n |				(level = 0 and: [token endsWith: ':'])					ifTrue: [s nextPutAll: token]					ifFalse: [(n := token occurrencesOf: $( ) > 0 ifTrue: [level := level + n].							(n := token occurrencesOf: $[ ) > 0 ifTrue: [level := level + n].							(n := token occurrencesOf: $] ) > 0 ifTrue: [level := level - n].							(n := token occurrencesOf: $) ) > 0 ifTrue: [level := level - n]]]]].	sel isEmpty ifTrue: [^ nil].	sel isOctetString ifTrue: [sel := sel asOctetString].	Symbol hasInterned: sel ifTrue:		[:aSymbol | ^ aSymbol].	^ nil! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!initialIntegerOrNil	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"	| firstNonDigit |	(self size == 0 or: [self first isDigit not]) ifTrue: [^ nil].	firstNonDigit := (self findFirst: [:m | m isDigit not]).	firstNonDigit = 0 ifTrue: [firstNonDigit := self size + 1].	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber"'234Whoopie' initialIntegerOrNil'wimpy' initialIntegerOrNil'234' initialIntegerOrNil'2N' initialIntegerOrNil'2' initialIntegerOrNil'  89Ten ' initialIntegerOrNil'78 92' initialIntegerOrNil"! !!String methodsFor: 'converting' stamp: 'nice 12/26/2009 22:14'!keywords	"Answer an array of the keywords that compose the receiver."	| keywords |	keywords := Array streamContents:		[:kwds |		| kwd |		kwd := WriteStream on: (String new: 16).		1 to: self size do:			[:i |			| char |			kwd nextPut: (char := self at: i).			char = $: ifTrue: 					[kwds nextPut: kwd contents.					kwd reset]].		(kwd position = 0) ifFalse: [kwds nextPut: kwd contents]].	(keywords size >= 1 and: [(keywords at: 1) = ':']) ifTrue:		["Has an initial keyword, as in #:if:then:else:"		keywords := keywords allButFirst].	(keywords size >= 2 and: [(keywords at: keywords size - 1) = ':']) ifTrue:		["Has a final keyword, as in #nextPut::andCR"		keywords := keywords copyReplaceFrom: keywords size - 1								to: keywords size with: {':' , keywords last}].	^ keywords! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!numericSuffix	^ self stemAndNumericSuffix last"'abc98' numericSuffix'98abc' numericSuffix"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!onlyLetters	"answer the receiver with only letters"	^ self select:[:each | each isLetter]! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!romanNumber	| value v1 v2 |	value := v1 := v2 := 0.	self reverseDo:		[:each |		v1 := #(1 5 10 50 100 500 1000) at: ('IVXLCDM' indexOf: each).		v1 >= v2			ifTrue: [value := value + v1]			ifFalse: [value := value - v1].		v2 := v1].	^ value! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!sansPeriodSuffix	"Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. "	| likely |	likely := self copyUpTo: $..	^ likely size == 0		ifTrue:	[self]		ifFalse:	[likely]! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 11:13'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.	'43Sam' ==> #(43 'Sam').  'Try90' ==> #('Try' 90)	BUT NOTE: 'Sam' ==> #('Sam' 0), and '90' ==> #('' 90)  ie, (<string> <integer>)."	| pos |	(pos := self findFirst: [:d | d isDigit not]) = 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 				with: (self copyFrom: pos to: self size)].	(pos := self findFirst: [:d | d isDigit]) = 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!String methodsFor: 'converting' stamp: 'ul 3/26/2010 23:51'!squeakToUtf8	"Convert the receiver into a UTF8-encoded string"		^self convertToWithConverter: UTF8TextConverter new.! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!stemAndNumericSuffix	"Parse the receiver into a string-valued stem and a numeric-valued suffix.  6/7/96 sw"	| stem suffix position |	stem := self.	suffix := 0.	position := 1.	[stem endsWithDigit and: [stem size > 1]] whileTrue:		[suffix :=  stem last digitValue * position + suffix.		position := position * 10.		stem := stem copyFrom: 1 to: stem size - 1].	^ Array with: stem with: suffix"'Fred2305' stemAndNumericSuffix"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!subStrings	"Answer an array of the substrings that compose the receiver."	#Collectn.	"Added 2000/04/08 For ANSI <readableString> protocol."	^ self substrings! !!String methodsFor: 'converting' stamp: 'ar 4/12/2005 16:32'!subStrings: separators 	"Answer an array containing the substrings in the receiver separated 	by the elements of separators."	| char result sourceStream subString |	#Collectn.	"Changed 2000/04/08 For ANSI <readableString> protocol."	(separators isString or:[separators allSatisfy: [:element | element isKindOf: Character]])		ifFalse: [^ self error: 'separators must be Characters.'].	sourceStream := ReadStream on: self.	result := OrderedCollection new.	subString := String new.	[sourceStream atEnd]		whileFalse: 			[char := sourceStream next.			(separators includes: char)				ifTrue: [subString notEmpty						ifTrue: 							[result add: subString copy.							subString := String new]]				ifFalse: [subString := subString , (String with: char)]].	subString notEmpty ifTrue: [result add: subString copy].	^ result asArray! !!String methodsFor: 'converting' stamp: 'ar 7/21/2007 21:50'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result := WriteStream on: (Array new: 10).	end := 0.	"find one substring each time through this loop"	[ "find the beginning of the next substring"	beginning := end+1.	[beginning <= self size and:[(self at: beginning) isSeparator]]		whileTrue:[beginning := beginning + 1].	beginning <= self size] whileTrue: [		"find the end"		end := beginning.		[end <= self size and:[(self at: end) isSeparator not]]			whileTrue:[end := end + 1].		end := end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!surroundedBySingleQuotes	"Answer the receiver with leading and trailing quotes.  "	^ $' asString, self, $' asString! !!String methodsFor: 'converting' stamp: 'yo 8/28/2002 15:14'!translateFrom: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	self class translate: self from: start to: stop table: table! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!translateToLowercase	"Translate all characters to lowercase, in place"	self translateWith: LowercasingTable! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!translateToUppercase	"Translate all characters to lowercase, in place"	self translateWith: UppercasingTable! !!String methodsFor: 'converting' stamp: 'yo 8/28/2002 15:13'!translateWith: table	"translate the characters in the string by the given table, in place"	^ self translateFrom: 1 to: self size table: table! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!truncateTo: smallSize	"return myself or a copy shortened to smallSize.  1/18/96 sw"	^ self size <= smallSize		ifTrue:			[self]		ifFalse:			[self copyFrom: 1 to: smallSize]! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!truncateWithElipsisTo: maxLength	"Return myself or a copy suitably shortened but with elipsis added"	^ self size <= maxLength		ifTrue:			[self]		ifFalse:			[(self copyFrom: 1 to: (maxLength - 3)), '...']	"'truncateWithElipsisTo:' truncateWithElipsisTo: 20"! !!String methodsFor: 'converting' stamp: 'KR 9/22/2005 23:06'!unescapePercents	"decode %xx form.  This is the opposite of #encodeForHTTP"	^ self unescapePercentsWithTextEncoding: 'utf-8'.! !!String methodsFor: 'converting' stamp: 'ky 7/8/2006 17:56'!unescapePercentsWithTextEncoding: encodingName 	"decode string including %XX form"	| unescaped char asciiVal specialChars oldPos pos converter |	unescaped := ReadWriteStream on: String new.	specialChars := '+%' asCharacterSet.	oldPos := 1.	[pos := self indexOfAnyOf: specialChars startingAt: oldPos.	pos > 0]		whileTrue: [unescaped				nextPutAll: (self copyFrom: oldPos to: pos - 1).			char := self at: pos.			(char = $%					and: [pos + 2 <= self size])				ifTrue: [asciiVal := (self at: pos + 1) asUppercase digitValue * 16 + (self at: pos + 2) asUppercase digitValue.					asciiVal > 255						ifTrue: [^ self].					unescaped						nextPut: (Character value: asciiVal).					pos := pos + 3.					pos <= self size						ifFalse: [char := nil].					oldPos := pos]				ifFalse: [char = $+						ifTrue: [unescaped nextPut: Character space]						ifFalse: [unescaped nextPut: char].					oldPos := pos + 1]].	oldPos <= self size		ifTrue: [unescaped				nextPutAll: (self copyFrom: oldPos to: self size)].	converter := (TextConverter newForEncoding: encodingName)				ifNil: [TextConverter newForEncoding: nil].	^ [unescaped contents convertFromWithConverter: converter]		on: Error		do: ["the contents may be squeak-encoded"			unescaped contents]! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 11:20'!unparenthetically	"If the receiver starts with (..( and ends with matching )..), strip them"	| curr |	curr := self.	[((curr first = $() and: [curr last = $)])] whileTrue:		[curr := curr copyFrom: 2 to: (curr size - 1)].	^ curr"'((fred the bear))' unparenthetically"		! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!unzipped	| magic1 magic2 |	magic1 := (self at: 1) asInteger.	magic2 := (self at: 2) asInteger.	(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse:[^self].	^(GZipReadStream on: self) upToEnd! !!String methodsFor: 'converting' stamp: 'ul 3/26/2010 23:51'!utf8ToSqueak	"Convert the receiver from a UTF8-encoded string"		^self convertFromWithConverter: UTF8TextConverter new.! !!String methodsFor: 'converting' stamp: 'nice 12/26/2009 22:15'!withBlanksCondensed	"Return a copy of the receiver with leading/trailing blanks removed	 and consecutive white spaces condensed."	^String streamContents: [:stream |		| trimmed lastBlank |		trimmed := self withBlanksTrimmed.		lastBlank := false.		trimmed do: [:c | (c isSeparator and: [lastBlank]) ifFalse: [stream nextPut: c].			lastBlank := c isSeparator]].	" ' abc  d   ' withBlanksCondensed"! !!String methodsFor: 'converting' stamp: 'nice 11/16/2009 17:19'!withBlanksTrimmed	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."	| first last |	first := self indexOfAnyOf: CSNonSeparators startingAt: 1 ifAbsent: [0].	first = 0 ifTrue: [ ^'' ].  "no non-separator character"	last := self lastIndexOfAnyOf: CSNonSeparators startingAt: self size ifAbsent: [self size].	(first = 1 and: [ last = self size ]) ifTrue: [ ^self copy ].	^self		copyFrom: first		to: last! !!String methodsFor: 'converting' stamp: 'md 9/19/2004 15:19'!withFirstCharacterDownshifted	"Return a copy with the first letter downShifted"		| answer |		self ifEmpty: [^ self copy].	answer := self copy.	answer at: 1 put: (answer at: 1) asLowercase.	^ answer. ! !!String methodsFor: 'converting' stamp: 'ar 1/11/2010 19:55'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end | | lineStart |				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [endWithoutDelimiters + 1]) min: endWithoutDelimiters.				[| lineEnd spacePosition |				lineEnd := 0.				spacePosition := lineStart.				[spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [lineStart + aNumber + 1].				spacePosition - lineStart <= (aNumber min: endWithoutDelimiters - lineStart)]						whileTrue: [lineEnd := spacePosition].				lineEnd = 0					ifTrue: ["no space - split arbitrarily"						lineEnd := lineStart + aNumber - 1 min: endWithoutDelimiters.						stream nextPutAll: (self copyFrom: lineStart to: lineEnd).						lineStart := lineEnd + 1]					ifFalse: ["split before space"						stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).						"eliminate conscutive spaces at split"						lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd + 1 ifAbsent: [endWithoutDelimiters + 1] ].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: endWithoutDelimiters + 1 to: end) ] ]! !!String methodsFor: 'converting' stamp: 'jmv 8/6/2009 09:17'!withoutJustTrailingDigits	"Answer the portion of the receiver that precedes any trailing series of digits.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstDigit |	firstDigit := (self findFirst: [:m | m isDigit]).	^ firstDigit > 0		ifTrue:			[(self copyFrom: 1 to: firstDigit-1) withoutTrailingBlanks]		ifFalse:			[self]"'Wh oopi e234' withoutJustTrailingDigits'Wh oopi e 234' withoutJustTrailingDigits"! !!String methodsFor: 'converting' stamp: 'md 10/5/2005 11:01'!withoutLeadingBlanks		"Return a copy of the receiver from which leading blanks have beentrimmed."		| first |		first := self findFirst: [:c | c isSeparator not ].	first = 0 ifTrue: [^ ''].  		"no non-separator character"		^ self copyFrom: first to: self size				" '    abc  d' withoutLeadingBlanks"! !!String methodsFor: 'converting' stamp: 'tak 4/25/2004 12:57'!withSeparatorsCompacted	"replace each sequences of whitespace by a single space character"	"' test ' withSeparatorsCompacted = ' test '"	"' test test' withSeparatorsCompacted = ' test test'"	"'test test		' withSeparatorsCompacted = 'test test '"	| out in next isSeparator |	self isEmpty ifTrue: [^ self].	out := WriteStream on: (String new: self size).	in := self readStream.	isSeparator := [:char | char asciiValue < 256				and: [CSSeparators includes: char]].	[in atEnd] whileFalse: [		next := in next.		(isSeparator value: next)			ifTrue: [				out nextPut: $ .				[in atEnd or:					[next := in next.					(isSeparator value: next)						ifTrue: [false]						ifFalse: [out nextPut: next. true]]] whileFalse]			ifFalse: [out nextPut: next]].	^ out contents! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:06'!withoutLeadingDigits	"Answer the portion of the receiver that follows any leading series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstNonDigit |	firstNonDigit := (self findFirst: [:m | m isDigit not and: [m ~= $ ]]).	^ firstNonDigit > 0		ifTrue:			[self copyFrom: firstNonDigit  to: self size]		ifFalse:			['']"'234Whoopie' withoutLeadingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!withoutTrailingBlanks	"Return a copy of the receiver from which trailing blanks have been trimmed."	| last |	last := self findLast: [:c | c isSeparator not].	last = 0 ifTrue: [^ ''].  "no non-separator character"	^ self copyFrom: 1 to: last	" ' abc  d   ' withoutTrailingBlanks"! !!String methodsFor: 'converting' stamp: 'yo 8/27/2002 14:06'!withoutTrailingDigits	"Answer the portion of the receiver that precedes any trailing series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstDigit |	firstDigit := (self findFirst: [:m | m isDigit or: [m = $ ]]).	^ firstDigit > 0		ifTrue:			[self copyFrom: 1 to: firstDigit-1]		ifFalse:			[self]"'Whoopie234' withoutTrailingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'converting' stamp: 'dgd 11/26/2005 21:19'!zipped	| stream gzstream |	stream := RWBinaryOrTextStream on: String new.	gzstream := GZipWriteStream on: stream.	gzstream nextPutAll: self.	gzstream close.	stream reset.	^ stream contents.! !!String methodsFor: 'copying' stamp: 'yo 11/3/2004 19:24'!copyReplaceTokens: oldSubstring with: newSubstring 	"Replace all occurrences of oldSubstring that are surrounded	by non-alphanumeric characters"	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'"! !!String methodsFor: 'copying' stamp: 'yo 11/3/2004 19:24'!deepCopy	"DeepCopy would otherwise mean make a copy of the character;  since 	characters are unique, just return a shallowCopy."	^self shallowCopy! !!String methodsFor: 'copying' stamp: 'yo 11/3/2004 19:24'!padded: leftOrRight to: length with: char	leftOrRight = #left ifTrue:		[^ (String new: (length - self size max: 0) withAll: char) , self].	leftOrRight = #right ifTrue:		[^ self , (String new: (length - self size max: 0) withAll: char)].! !!String methodsFor: 'displaying' stamp: 'yo 11/3/2004 19:24'!displayAt: aPoint 	"Display the receiver as a DisplayText at aPoint on the display screen."	self displayOn: Display at: aPoint! !!String methodsFor: 'displaying' stamp: 'yo 11/3/2004 19:24'!displayOn: aDisplayMedium	"Display the receiver on the given DisplayMedium.  5/16/96 sw"	self displayOn: aDisplayMedium at: 0 @ 0! !!String methodsFor: 'displaying' stamp: 'yo 11/3/2004 19:24'!displayOn: aDisplayMedium at: aPoint 	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."	self displayOn: aDisplayMedium at: aPoint textColor: Color black! !!String methodsFor: 'displaying' stamp: 'yo 11/3/2004 19:24'!displayOn: aDisplayMedium at: aPoint textColor: aColor	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, rendering the text in the designated color"	(self asDisplayText foregroundColor: (aColor ifNil: [Color black]) backgroundColor: Color white)		displayOn: aDisplayMedium at: aPoint! !!String methodsFor: 'displaying' stamp: 'yo 11/3/2004 19:24'!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressAt: Sensor cursorPoint	from: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range."	^ProgressInitiationException 		display: self		at: aPoint 		from: minVal 		to: maxVal 		during: workBlock! !!String methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:16'!getInteger32: location	| integer |	<primitive: 'getInteger' module: 'IntegerPokerPlugin'>	"^IntegerPokerPlugin doPrimitive: #getInteger"	"the following is about 7x faster than interpreting the plugin if not compiled"	integer := 		((self at: location) asInteger bitShift: 24) +		((self at: location+1) asInteger bitShift: 16) +		((self at: location+2) asInteger bitShift: 8) +		(self at: location+3) asInteger.	integer > 1073741824 ifTrue: [^1073741824 - integer ].	^integer! !!String methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:17'!putInteger32: anInteger at: location	| integer |	<primitive: 'putInteger' module: 'IntegerPokerPlugin'>	"IntegerPokerPlugin doPrimitive: #putInteger"	"the following is close to 20x faster than the above if the primitive is not compiled"	"PUTCOUNTER := PUTCOUNTER + 1."	integer := anInteger.	integer < 0 ifTrue: [integer :=  1073741824 - integer. ].	self at: location+3 put: (Character value: (integer \\ 256)).	self at: location+2 put: (Character value: (integer bitShift: -8) \\ 256).	self at: location+1 put: (Character value: (integer bitShift: -16) \\ 256).	self at: location put: (Character value: (integer bitShift: -24) \\ 256)."Smalltalk at: #PUTCOUNTER put: 0"! !!String methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:18'!writeLeadingCharRunsOn: stream	| runLength runValues runStart leadingChar |	self isEmpty ifTrue: [^ self].	runLength := OrderedCollection new.	runValues := OrderedCollection new.	runStart := 1.	leadingChar := (self at: runStart) leadingChar.	2 to: self size do: [:index |		(self at: index) leadingChar = leadingChar ifFalse: [			runValues add: leadingChar.			runLength add: (index - runStart).			leadingChar := (self at: index) leadingChar.			runStart := index.		].	].	runValues add: (self last) leadingChar.	runLength add: self size + 1 -  runStart.	stream nextPut: $(.	runLength do: [:rr | rr printOn: stream. stream space].	stream skip: -1; nextPut: $).	runValues do: [:vv | vv printOn: stream. stream nextPut: $,].	stream skip: -1.! !!String methodsFor: 'filter streaming' stamp: 'yo 8/26/2002 22:31'!byteEncode:aStream	^aStream writeString: self.! !!String methodsFor: 'filter streaming' stamp: 'yo 8/26/2002 22:31'!putOn:aStream	^aStream nextPutAll: self.! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacros	^self expandMacrosWithArguments: #()! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacrosWithArguments: anArray 	| newStream readStream char index |	newStream := WriteStream on: (String new: self size).	readStream := ReadStream on: self.	[readStream atEnd] whileFalse: 			[char := readStream next.			char == $< 				ifTrue: 					[| nextChar |					nextChar := readStream next asUppercase.					nextChar == $N ifTrue: [newStream cr].					nextChar == $T ifTrue: [newStream tab].					nextChar isDigit 						ifTrue: 							[index := nextChar digitValue.														[readStream atEnd 								or: [(nextChar := readStream next asUppercase) isDigit not]] 									whileFalse: [index := index * 10 + nextChar digitValue]].					nextChar == $? 						ifTrue: 							[| trueString falseString |							trueString := readStream upTo: $:.							falseString := readStream upTo: $>.							readStream position: readStream position - 1.							newStream 								nextPutAll: ((anArray at: index) ifTrue: [trueString] ifFalse: [falseString])].					nextChar == $P 						ifTrue: [newStream nextPutAll: (anArray at: index) printString].					nextChar == $S ifTrue: [newStream nextPutAll: (anArray at: index)].					readStream skipTo: $>]				ifFalse: 					[newStream nextPut: (char == $% ifTrue: [readStream next] ifFalse: [char])]].	^newStream contents! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacrosWith: anObject 	^self expandMacrosWithArguments: (Array with: anObject)! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacrosWith: anObject with: anotherObject 	^self 		expandMacrosWithArguments: (Array with: anObject with: anotherObject)! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacrosWith: anObject with: anotherObject with: thirdObject 	^self expandMacrosWithArguments: (Array 				with: anObject				with: anotherObject				with: thirdObject)! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacrosWith: anObject with: anotherObject with: thirdObject with: fourthObject 	^self expandMacrosWithArguments: (Array 				with: anObject				with: anotherObject				with: thirdObject				with: fourthObject)! !!String methodsFor: 'formatting' stamp: 'ul 10/12/2009 21:31'!format: aCollection 	"format the receiver with aCollection  	 	simplest example:  	'foo {1} bar' format: {Date today}.	 	complete example:  	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}. 	"	^String new: self size streamContents: [ :result |		| stream currentChar |		stream := self readStream.		[ (currentChar := stream next) == nil ] whileFalse: [			currentChar == ${				ifTrue: [					result nextPutAll: (						self 							evaluateExpression: (stream upTo: $}) withBlanksTrimmed 								parameters: aCollection) ]				ifFalse: [					currentChar == $\						ifFalse: [ result nextPut: currentChar ]						ifTrue: [							(currentChar := stream next) ifNotNil: [								result nextPut: currentChar ] ] ] ] ]! !!String methodsFor: 'formatting' stamp: 'yo 11/3/2004 19:24'!withCRs	"Return a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."	^ self collect: [ :c | c = $\ ifTrue: [ Character cr ] ifFalse: [ c ]].! !!String methodsFor: 'internet' stamp: 'yo 12/28/2003 01:17'!decodeMimeHeader	"See RFC 2047, MIME Part Three: Message Header Extension for Non-ASCII  	Text. Text containing non-ASCII characters is encoded by the sequence  	=?character-set?encoding?encoded-text?=  	Encoding is Q (quoted printable) or B (Base64), handled by  	Base64MimeConverter / RFC2047MimeConverter.	Thanks to Yokokawa-san, it works in m17n package.  Try the following:	'=?ISO-2022-JP?B?U1dJS0lQT1AvGyRCPUJDKyVpJXMlQRsoQi8=?= =?ISO-2022-JP?B?GyRCJVElRiUjJSobKEIoUGF0aW8p?=' decodeMimeHeader."	| input output temp charset decoder encodedStream encoding pos |	input := ReadStream on: self.	output := WriteStream on: String new.	[output		nextPutAll: (input upTo: $=).	"ASCII Text"	input atEnd]		whileFalse: [(temp := input next) = $?				ifTrue: [charset := input upTo: $?.					encoding := (input upTo: $?) asUppercase.					temp := input upTo: $?.					input next.					"Skip final ="					(charset isNil or: [charset size = 0]) ifTrue: [charset := 'LATIN-1'].					encodedStream := MultiByteBinaryOrTextStream on: String new encoding: charset.					decoder := encoding = 'B'								ifTrue: [Base64MimeConverter new]								ifFalse: [RFC2047MimeConverter new].					decoder						mimeStream: (ReadStream on: temp);						 dataStream: encodedStream;						 mimeDecode.					output nextPutAll: encodedStream reset contents.					pos := input position.					input skipSeparators.					"Delete spaces if followed by ="					input peek = $=						ifFalse: [input position: pos]]				ifFalse: [output nextPut: $=;						 nextPut: temp]].	^ output contents! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!decodeQuotedPrintable	"Assume receiver is in MIME 'quoted-printable' encoding, and decode it."  	^QuotedPrintableMimeConverter mimeDecode: self as: self class! !!String methodsFor: 'internet' stamp: 'ar 4/9/2005 22:16'!isoToSqueak	^self "no longer needed"! !!String methodsFor: 'internet' stamp: 'nice 12/26/2009 22:13'!isoToUtf8	"Convert ISO 8559-1 to UTF-8"	| s |	s := WriteStream on: (String new: self size).	self do: [:c |		| v |		v := c asciiValue.		(v > 128)			ifFalse: [s nextPut: c]			ifTrue: [				s nextPut: (192+(v >> 6)) asCharacter.				s nextPut: (128+(v bitAnd: 63)) asCharacter]].	^s contents. ! !!String methodsFor: 'internet' stamp: 'ar 4/10/2005 15:58'!macToSqueak	"Convert the receiver from MacRoman to Squeak encoding"	^ self collect: [:each | each macToSqueak]! !!String methodsFor: 'internet' stamp: 'ar 4/9/2005 22:16'!squeakToIso	^self "no longer needed"! !!String methodsFor: 'internet' stamp: 'ar 4/10/2005 15:55'!squeakToMac	"Convert the receiver from Squeak to MacRoman encoding"	^ self collect: [:each | each squeakToMac]! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!utf8ToIso	"Only UTF-8 characters that maps to 8-bit ISO-8559-1 values are converted. Others raises an error"	| s i c v c2 v2 |	s := WriteStream on: (String new: self size).		i := 1.	[i <= self size] whileTrue: [		c := self at: i. i:=i+1.		v := c asciiValue.		(v > 128)			ifFalse: [ s nextPut: c ]			ifTrue: [((v bitAnd: 252) == 192)				ifFalse: [self error: 'illegal UTF-8 ISO character']				ifTrue: [					(i > self size) ifTrue: [ self error: 'illegal end-of-string, expected 2nd byte of UTF-8'].					c2 := self at: i. i:=i+1.					v2 := c2 asciiValue.					((v2 bitAnd: 192) = 128) ifFalse: [self error: 'illegal 2nd UTF-8 char']. 					s nextPut: ((v2 bitAnd: 63) bitOr: ((v << 6) bitAnd: 192)) asCharacter]]].	^s contents. ! !!String methodsFor: 'internet' stamp: 'nice 1/18/2010 22:43'!withInternetLineEndings	"change line endings from CR's and LF's to CRLF's.  This is probably in prepration for sending a string over the Internet"		^self class		new: self size * 16 // 15 "provisions for CR-LF pairs"		streamContents: [ :stream |			self lineIndicesDo: [:start :endWithoutDelimiters :end |				stream next: 1 + endWithoutDelimiters - start putAll: self startingAt: start.				endWithoutDelimiters = end ifFalse: [					stream crlf ] ] ]! !!String methodsFor: 'internet' stamp: 'nice 1/18/2010 23:37'!withSqueakLineEndings	"Assume the string is textual, and that CR, LF, and CRLF are all valid line endings.	Replace each occurence with a single CR."	| cr lf inPos outPos outString newOutPos indexLF indexCR |	lf := Character linefeed.	indexLF := self indexOf: lf startingAt: 1.	indexLF = 0 ifTrue: [^self].		cr := Character cr.	indexCR := self indexOf: cr startingAt: 1.	indexCR = 0 ifTrue: [^self copy replaceAll: lf with: cr].	inPos := outPos := 1.	outString := String new: self size.	["check if next CR (if any) is before next LF"	(indexCR > 0 and: [indexCR < indexLF])		ifTrue: [			newOutPos := outPos + 1 + indexCR - inPos.			outString replaceFrom: outPos to: newOutPos - 1 with: self startingAt: inPos.			outPos := newOutPos.			1 + indexCR = indexLF				ifTrue: ["Caught a CR-LF pair"					inPos := 1 + indexLF.					indexLF := self  indexOf: lf startingAt: inPos]				ifFalse: [inPos := 1 + indexCR].			indexCR := self indexOf: cr startingAt: inPos]		ifFalse: [			newOutPos := outPos + 1 + indexLF - inPos.			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos - 1 put: cr.			outPos := newOutPos.			inPos := 1 + indexLF.			indexLF := self indexOf: lf startingAt: inPos].	indexLF = 0]		whileFalse.	"no more LF line endings.  copy the rest"	newOutPos := outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos - 1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos - 1! !!String methodsFor: 'internet' stamp: 'nice 1/18/2010 23:36'!withUnixLineEndings	"Assume the string is textual, and that CR, LF, and CRLF are all valid line endings.	Replace each occurence with a single LF."	| cr lf inPos outPos outString newOutPos indexLF indexCR |	cr := Character cr.	indexCR := self indexOf: cr startingAt: 1.	indexCR = 0 ifTrue: [^self].		lf := Character linefeed.	indexLF := self indexOf: lf startingAt: 1.	indexLF = 0 ifTrue: [^self copy replaceAll: cr with: lf].	inPos := outPos := 1.	outString := String new: self size.	["check if next CR is before next LF or if there are no more LF"	(indexLF = 0 or: [indexCR < indexLF])		ifTrue: [			newOutPos := outPos + 1 + indexCR - inPos.			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos - 1 put: lf.			outPos := newOutPos.			1 + indexCR = indexLF				ifTrue: ["Caught a CR-LF pair"					inPos := 1 + indexLF.					indexLF := self  indexOf: lf startingAt: inPos]				ifFalse: [inPos := 1 + indexCR].			indexCR := self indexOf: cr startingAt: inPos]		ifFalse: [			newOutPos := outPos + 1 + indexLF - inPos.			outString replaceFrom: outPos to: newOutPos - 1 with: self startingAt: inPos.			outPos := newOutPos.			inPos := 1 + indexLF.			indexLF := self indexOf: lf startingAt: inPos].	indexCR = 0]		whileFalse.	"no more CR line endings.  copy the rest"	newOutPos := outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos - 1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos - 1! !!String methodsFor: 'internet' stamp: 'yo 11/3/2004 19:24'!withoutQuoting	"remove the initial and final quote marks, if present"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote := self first.	(quote = $' or: [ quote = $" ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!String methodsFor: 'paragraph support' stamp: 'nice 2/8/2010 11:27'!indentationIfBlank: aBlock	"Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."	| leadingTabs nonTab nonTabIndex nonSepIndex lineEndIndex |	nonTab := (CharacterSet with: Character tab) complement.	nonTabIndex := self indexOfAnyOf: nonTab startingAt: 1.	nonTabIndex = 0 ifTrue: [		"Only made of tabs or empty"		^aBlock value: self size].	leadingTabs := nonTabIndex - 1.	nonSepIndex := self indexOfAnyOf: CSNonSeparators startingAt: 1.	nonSepIndex = 0 ifTrue: [		"Only made of separators"		^aBlock value: leadingTabs].	lineEndIndex := self indexOfAnyOf: CSLineEnders startingAt: 1.	(lineEndIndex between: 1 and: nonSepIndex) ifTrue: [		"Only made of separators up to a line end"		^aBlock value: leadingTabs].	^leadingTabs! !!String methodsFor: 'printing' stamp: 'yo 8/26/2002 22:57'!encodeDoublingQuoteOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream print: $'.	1 to: self size do:		[:i |		aStream print: (x := self at: i).		x = $' ifTrue: [aStream print: x]].	aStream print: $'! !!String methodsFor: 'printing' stamp: 'yo 11/3/2004 19:24'!isLiteral	^true! !!String methodsFor: 'printing' stamp: 'sd 7/8/2006 18:06'!printOn: aStream 	"Print inside string quotes, doubling inbedded quotes." 	self storeOn: aStream! !!String methodsFor: 'printing' stamp: 'yo 8/26/2002 22:58'!storeOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream nextPut: $'.	1 to: self size do:		[:i |		aStream nextPut: (x := self at: i).		x = $' ifTrue: [aStream nextPut: x]].	aStream nextPut: $'! !!String methodsFor: 'printing' stamp: 'yo 11/3/2004 19:24'!stringRepresentation	"Answer a string that represents the receiver.  For most objects this is simply its printString, but for strings themselves, it's themselves, to avoid the superfluous extra pair of quotes.  6/12/96 sw"	^ self ! !!String methodsFor: 'system primitives' stamp: 'sw 10/20/2004 17:51'!endsWithAColon 	"Answer whether the final character of the receiver is a colon"	^ self size > 0 and: [self last == $:]"#fred: endsWithAColon'fred' endsWithAColon"! !!String methodsFor: 'system primitives' stamp: 'ul 9/14/2009 02:59'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned."	| index c1 c2 |	matchTable == nil ifTrue: [		key size = 0 ifTrue: [^ 0].		start to: body size - key size + 1 do:			[:startIndex |			index := 1.				[(body at: startIndex+index-1)					= (key at: index)]					whileTrue:					[index = key size ifTrue: [^ startIndex].					index := index+1]].		^ 0	].	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.		[c1 := body at: startIndex+index-1.		c2 := key at: index.		((c1 leadingChar = 0 and: [ c1 asciiValue < matchTable size ]) 			ifTrue: [ matchTable at: c1 asciiValue + 1 ]			ifFalse: [ c1 asciiValue + 1 ]) = 			((c2 leadingChar = 0 and: [ c2 asciiValue < matchTable size ])				ifTrue: [ matchTable at: c2 asciiValue + 1 ]				ifFalse: [c2 asciiValue + 1 ]) ]			whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0! !!String methodsFor: 'system primitives' stamp: 'nice 7/28/2007 00:15'!numArgs 	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons excess start ix |	self size = 0 ifTrue: [^ -1].	firstChar := self at: 1.	(firstChar isLetter or: [firstChar = $:]) ifTrue:		["Fast reject if any chars are non-alphanumeric		NOTE: fast only for Byte things - Broken for Wide"		self class isBytes			ifTrue: [(self findSubstring: '~' in: self startingAt: 1 matchTable: Tokenish) > 0 ifTrue: [^ -1]]			ifFalse: [2 to: self size do: [:i | (self at: i) tokenish ifFalse: [^ -1]]].		"Fast colon count"		numColons := 0.  start := 1.		[(ix := self indexOf: $: startingAt: start) > 0]			whileTrue:				[numColons := numColons + 1.				start := ix + 1].		numColons = 0 ifTrue: [^ 0].		firstChar = $:			ifTrue: [excess := 2 "Has an initial keyword, as #:if:then:else:"]			ifFalse: [excess := 0].		self last = $:			ifTrue: [^ numColons - excess]			ifFalse: [^ numColons - excess - 1 "Has a final keywords as #nextPut::andCR"]].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		2 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].		^ 1].	^ -1.! !!String methodsFor: 'testing' stamp: 'ar 4/10/2005 16:49'!includesUnifiedCharacter	^false! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!isAllDigits	"whether the receiver is composed entirely of digits"	self do: [:c | c isDigit ifFalse: [^ false]].	^ true! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!isAllSeparators	"whether the receiver is composed entirely of separators"	self do: [ :c | c isSeparator ifFalse: [ ^false ] ].	^true! !!String methodsFor: 'testing' stamp: 'yo 8/4/2003 12:26'!isAsciiString	| c |	c := self detect: [:each | each asciiValue > 127] ifNone: [nil].	^ c isNil.! !!String methodsFor: 'testing' stamp: 'ar 4/10/2005 16:23'!isByteString	"Answer whether the receiver is a ByteString"	^false! !!String methodsFor: 'testing' stamp: 'ar 4/10/2005 23:25'!isOctetString	"Answer whether the receiver can be represented as a byte string. 	This is different from asking whether the receiver *is* a ByteString 	(i.e., #isByteString)"	1 to: self size do: [:pos |		(self at: pos) asInteger >= 256 ifTrue: [^ false].	].	^ true.! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!isString	^ true! !!String methodsFor: 'testing' stamp: 'ar 4/12/2005 19:52'!isWideString	"Answer whether the receiver is a WideString"	^false! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!lastSpacePosition	"Answer the character position of the final space or other separator character in the receiver, and 0 if none"	self size to: 1 by: -1 do:		[:i | ((self at: i) isSeparator) ifTrue: [^ i]].	^ 0"'fred the bear' lastSpacePosition'ziggie' lastSpacePosition'elvis ' lastSpacePosition'wimpy  ' lastSpacePosition'' lastSpacePosition"! !!String methodsFor: 'translating' stamp: 'dgd 8/24/2004 19:42'!translated	"answer the receiver translated to the default language"	^ NaturalLanguageTranslator current  translate: self! !!String methodsFor: 'translating' stamp: 'dgd 8/27/2004 18:43'!translatedIfCorresponds	"answer the receiver translated to the default language only if 	the receiver begins and ends with an underscore (_)"	^ ('_*_' match: self)		ifTrue: [(self copyFrom: 2 to: self size - 1) translated]		ifFalse: [self]! !!String methodsFor: 'translating' stamp: 'dgd 8/24/2004 19:38'!translatedTo: localeID 	"answer the receiver translated to the given locale id"	^ localeID translator translate: self! !!String methodsFor: 'user interface' stamp: 'md 7/28/2005 20:42'!asExplorerString	^ self printString! !!String methodsFor: 'user interface' stamp: 'ar 9/27/2005 20:02'!openInWorkspaceWithTitle: aTitle	"Open up a workspace with the receiver as its contents, with the given title"	UIManager default edit: self label: aTitle! !!String methodsFor: '*Morphic' stamp: 'ar 4/10/2005 17:07'!asMorph 	"Answer the receiver as a StringMorph"	^ StringMorph contents: self"'bugs black blood' asMorph openInHand"! !!String methodsFor: '*Morphic' stamp: 'ar 4/10/2005 17:07'!asStringMorph 	"Answer the receiver as a StringMorph"	^ StringMorph contents: self"'bugs black blood' asStringMorph openInHand"! !!String methodsFor: '*MorphicExtras-*morphic-Postscript Canvases' stamp: 'yo 11/3/2004 19:24'!asPostscript	| temp |	temp := self asString copyReplaceAll: '(' with: '\('.	temp := temp copyReplaceAll: ')' with: '\)'.	temp := temp copyReplaceAll: '' 			with: ''.	^ PostscriptEncoder mapMacStringToPS: temp! !!String methodsFor: '*Morphic-converting' stamp: 'yo 11/3/2004 19:24'!openAsMorph	"Open the receiver as a morph"	^ self asMorph openInHand ! !!String methodsFor: '*monticello' stamp: 'avi 2/4/2004 14:14'!extractNumber	^ ('0', self select: [:ea | ea isDigit]) asNumber! !!String methodsFor: '*network-uri' stamp: 'mir 2/26/2002 14:59'!asURI	"convert to a Url"	"'http://www.cc.gatech.edu/' asURI"	"'msw://chaos.resnet.gatech.edu:9000/' asURI"	^URI fromString: self! !!String methodsFor: '*packageinfo-base' stamp: 'nk 8/30/2004 09:02'!escapeEntities	^ self species streamContents: [:s | self do: [:c | s nextPutAll: c escapeEntities]]! !!String methodsFor: '*services-base' stamp: 'rr 3/21/2006 12:00'!service	^ self serviceOrNil ifNil: [ServiceCategory new id: self asSymbol]! !!String methodsFor: '*services-base' stamp: 'rr 3/21/2006 12:00'!serviceOrNil	^ ServiceRegistry current serviceWithId: self asSymbol! !!String methodsFor: '*versionnumber' stamp: 'yo 11/3/2004 19:24'!asVersion
	"Answer a VersionNumber"

	^VersionNumber fromString: self! !!String methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."	| choices results maxChoices scoreMin |	scoreMin := self size // 2 min: 3.	maxChoices := 10.	oldCollection isNil		ifTrue: [ choices := SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifFalse: [ choices := oldCollection ].	wordBlock isNil		ifTrue:			[ results := OrderedCollection new.			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word | | score |				(score := self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) value] ] ].			results := choices ].	^ results! !!String methodsFor: 'private' stamp: 'ul 10/13/2009 00:42'!evaluateExpression: aString parameters: aCollection 	"private - evaluate the expression aString with  	aCollection as the parameters and answer the  	evaluation result as an string"	| index |	index := Integer readFrom: aString readStream base: 10.	index isZero		ifTrue: [^ '[invalid subscript: {1}]' format: {aString}].	index > aCollection size		ifTrue: [^ '[subscript is out of bounds: {1}]' format: {aString}].	^ (aCollection at: index) asString! !!String methodsFor: 'private' stamp: 'yo 8/26/2002 22:53'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!String methodsFor: 'private' stamp: 'yo 8/28/2002 15:22'!stringhash	^ self hash.! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:32'!uversionEqual: anObject	^anObject isString and: [ self = anObject ]! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 21:13'!uversionLessThan: anObject	^anObject isInteger or: [ self < anObject ]! !!String methodsFor: '*Universes' stamp: 'ls 8/26/2007 09:16'!asUVersion	^UVersion readFromString: self! !!String methodsFor: '*Morphic-Explorer' stamp: 'yo 11/3/2004 19:24'!hasContentsInExplorer	^false! !!String methodsFor: 'deprecated-3.10' stamp: 'AdrianLienhard 8/26/2009 21:51'!findLastOccuranceOfString: subString startingAt: start 	self deprecated: 'Use instead #findLastOccurrenceOfString:startingAt:'.	^ self findLastOccurrenceOfString: subString startingAt: start ! !!String methodsFor: '*xml-parser' stamp: 'mir 7/14/2006 11:54'!applyLanguageInfomation: languageEnvironment		| leadingChar |	leadingChar := languageEnvironment leadingChar.	self withIndexDo: [:each :idx |		each asciiValue > 255			ifTrue: [self at: idx put: (Character leadingChar: leadingChar code: each asUnicode)]]! !!String methodsFor: '*ST80-Support' stamp: 'yo 11/3/2004 19:24'!asParagraph	"Answer a Paragraph whose text string is the receiver."	^Paragraph withText: self asText! !!String methodsFor: '*system' stamp: 'ar 2/13/2010 15:50'!suggestedTypeNames	^ Array streamContents:		[ : stream |		self withIndexDo:		[ : eachChar : index |		eachChar isUppercase ifTrue:			[ stream nextPut: 				(self					copyFrom: index					to: self size) withBlanksTrimmed.			"Often, argument names that refer to Collections end in the letter s, which can cause the suggested type-name to not be found.  Account for this."			self last = $s				ifTrue:					[ stream nextPut:						(self							copyFrom: index							to: self size-1) withBlanksTrimmed ] ] ] ]! !!String methodsFor: '*Etoys-tiles' stamp: 'yo 11/3/2004 19:24'!basicType	"Answer a symbol representing the inherent type of the receiver"	"Number String Boolean player collection sound color etc"	^ #String! !!String methodsFor: '*Etoys-tiles' stamp: 'ar 4/10/2005 17:06'!newTileMorphRepresentative	^ TileMorph new setLiteral: self;addSuffixIfCan! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!String class	instanceVariableNames: ''!!String class methodsFor: 'examples' stamp: 'yo 11/3/2004 19:24'!example	"To see the string displayed at the cursor point, execute this expression	and select a point by pressing a mouse button."	'this is some text' displayOn: Display at: Sensor waitButton! !!String class methodsFor: 'formatting' stamp: 'md 6/5/2005 07:49'!expandMacro: macroType argument: argument withExpansions: expansions 	macroType = $s ifTrue: [^expansions at: argument].	macroType = $p ifTrue: [^(expansions at: argument) printString].	macroType = $n ifTrue: [^String cr].	macroType = $t ifTrue: [^String tab].	self error: 'unknown expansion type'! !!String class methodsFor: 'initialization' stamp: 'nice 2/8/2010 10:20'!initialize   "self initialize"	| order |	AsciiOrder := (0 to: 255) as: ByteArray.	CaseInsensitiveOrder := AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder := ByteArray new: 256 withAll: 255.	order := -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order := order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order := order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order := order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order := order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable := String withAll: (Character allByteCharacters collect: [:c | c asLowercase]).	"a table for translating to upper case"	UppercasingTable := String withAll: (Character allByteCharacters collect: [:c | c asUppercase]).	"a table for testing tokenish (for fast numArgs)"	Tokenish := String withAll: (Character allByteCharacters collect:									[:c | c tokenish ifTrue: [c] ifFalse: [$~]]).	"CR and LF--characters that terminate a line"	CSLineEnders := CharacterSet crlf. 	"separators and non-separators"	CSSeparators := CharacterSet separators.	CSNonSeparators := CSSeparators complement.! !!String class methodsFor: 'initialization' stamp: 'yo 8/11/2003 21:11'!initializeHtmlEntities	"self initializeHtmlEntities"	HtmlEntities := (Dictionary new: 128)		at: 'amp'	put: $&;		at: 'lt'		put: $<;		at: 'gt'		put: $>;		at: 'quot'	put: $";		at: 'euro'	put: Character euro;		yourself.	#('nbsp' 'iexcl' 'cent' 'pound' 'curren' 'yen' 'brvbar' 'sect' 'uml' 'copy' 'ordf' 'laquo' 'not' 'shy' 'reg' 'hibar' 'deg' 'plusmn' 'sup2' 'sup3' 'acute' 'micro' 'para' 'middot' 'cedil' 'sup1' 'ordm' 'raquo' 'frac14' 'frac12' 'frac34' 'iquest' 'Agrave' 'Aacute' 'Acirc' 'Atilde' 'Auml' 'Aring' 'AElig' 'Ccedil' 'Egrave' 'Eacute' 'Ecirc' 'Euml' 'Igrave' 'Iacute' 'Icirc' 'Iuml' 'ETH' 'Ntilde' 'Ograve' 'Oacute' 'Ocirc' 'Otilde' 'Ouml' 'times' 'Oslash' 'Ugrave' 'Uacute' 'Ucirc' 'Uuml' 'Yacute' 'THORN' 'szlig' 'agrave' 'aacute' 'acirc' 'atilde' 'auml' 'aring' 'aelig' 'ccedil' 'egrave' 'eacute' 'ecirc' 'euml' 'igrave' 'iacute' 'icirc' 'iuml' 'eth' 'ntilde' 'ograve' 'oacute' 'ocirc' 'otilde' 'ouml' 'divide' 'oslash' 'ugrave' 'uacute' 'ucirc' 'uuml' 'yacute' 'thorn' 'yuml' ) withIndexDo: [:each :index | HtmlEntities at: each put: (index + 159) asCharacter]! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!cr	"Answer a string containing a single carriage return character."	^ self with: Character cr! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!crlf	"Answer a string containing a carriage return and a linefeed."	^ self with: Character cr with: Character lf! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!crlfcrlf	^self crlf , self crlf.! !!String class methodsFor: 'instance creation' stamp: 'cmm 2/11/2010 21:11'!empty	"A canonicalized empty String instance."	^ ''! !!String class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 16:24'!fromByteArray: aByteArray	^ aByteArray asString! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!fromPacked: aLong	"Convert from a longinteger to a String of length 4."	| s |	s := self new: 4.	s at: 1 put: (aLong digitAt: 4) asCharacter.	s at: 2 put: (aLong digitAt: 3) asCharacter.	s at: 3 put: (aLong digitAt: 2) asCharacter.	s at: 4 put: (aLong digitAt: 1) asCharacter.	^s"String fromPacked: 'TEXT' asPacked"! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!fromString: aString 	"Answer an instance of me that is a copy of the argument, aString."		^ aString copyFrom: 1 to: aString size! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!lf	"Answer a string containing a single carriage return character."	^ self with: Character lf! !!String class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 23:26'!new: sizeRequested 	"Answer an instance of this class with the number of indexable	variables specified by the argument, sizeRequested."	self == String 		ifTrue:[^ByteString new: sizeRequested]		ifFalse:[^self basicNew: sizeRequested].! !!String class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:27'!readFrom: inStream	"Answer an instance of me that is determined by reading the stream, 	inStream. Embedded double quotes become the quote Character."	| outStream char done |	outStream := WriteStream on: (self new: 16).	"go to first quote"	inStream skipTo: $'.	done := false.	[done or: [inStream atEnd]]		whileFalse: 			[char := inStream next.			char = $'				ifTrue: 					[char := inStream next.					char = $'						ifTrue: [outStream nextPut: char]						ifFalse: [done := true]]				ifFalse: [outStream nextPut: char]].	^outStream contents! !!String class methodsFor: 'instance creation' stamp: 'dc 2/12/2007 10:47'!space	"Answer a string containing a single space character."	^ self with: Character space! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!tab	"Answer a string containing a single tab character."	^ self with: Character tab! !!String class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:29'!value: anInteger	^ self with: (Character value: anInteger).! !!String class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 17:34'!with: aCharacter	| newCollection |	aCharacter asInteger < 256		ifTrue:[newCollection := ByteString new: 1]		ifFalse:[newCollection := WideString new: 1].	newCollection at: 1 put: aCharacter.	^newCollection! !!String class methodsFor: 'primitives' stamp: 'yo 12/15/2005 13:41'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	order == nil ifTrue: [		len1 := string1 size.		len2 := string2 size.		1 to: (len1 min: len2) do:[:i |			c1 := (string1 at: i) asInteger.			c2 := (string2 at: i) asInteger.			c1 = c2 ifFalse: [c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].		].		len1 = len2 ifTrue: [^ 2].		len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].	].	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:[:i |		c1 := (string1 at: i) asInteger.		c2 := (string2 at: i) asInteger.		c1 < 256 ifTrue: [c1 := order at: c1 + 1].		c2 < 256 ifTrue: [c2 := order at: c2 + 1].		c1 = c2 ifFalse:[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].	].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!String class methodsFor: 'primitives' stamp: 'nice 5/9/2006 20:17'!findFirstInString: aString inSet: inclusionMap startingAt: start	"Trivial, non-primitive version"		| i stringSize ascii more |	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize := aString size.	more := true.	i := start - 1.	[more and: [(i := i + 1) <= stringSize]] whileTrue: [		ascii := (aString at: i) asciiValue.		more := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i > stringSize ifTrue: [^ 0].	^ i! !!String class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:36'!indexOfAscii: anInteger inString: aString startingAt: start	"Trivial, non-primitive version"	| stringSize |	stringSize := aString size.	start to: stringSize do: [:pos |		(aString at: pos) asInteger = anInteger ifTrue: [^ pos]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:29'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	stringSize := aString size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash := hash + (aString at: pos) asInteger.		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash.! !!String class methodsFor: 'primitives' stamp: 'ar 4/10/2005 16:36'!translate: aString from: start  to: stop  table: table	"Trivial, non-primitive version"	| char |	start to: stop do: [:i |		char := (aString at: i) asInteger.		char < 256 ifTrue: [aString at: i put: (table at: char+1)].	].! !!String class methodsFor: 'accessing' stamp: 'ar 3/17/2007 21:21'!noSeparatorMap	^CSNonSeparators byteArrayMap! !!String class methodsFor: 'accessing' stamp: 'ar 3/17/2007 21:28'!separatorMap	^CSSeparators byteArrayMap! !String initialize!