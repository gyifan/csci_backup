'From Squeak4.1 of 17 April 2010 [latest update: #9957] on 9 February 2012 at 5:05 pm'!Number subclass: #Integer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!Integer commentStamp: '<historical>' prior: 0!I am a common abstract superclass for all Integer implementations. My implementation subclasses are SmallInteger, LargePositiveInteger, and LargeNegativeInteger.	Integer division consists of:	/	exact division, answers a fraction if result is not a whole integer	//	answers an Integer, rounded towards negative infinity	\\	is modulo rounded towards negative infinity	quo: truncated division, rounded towards zero!!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!* aNumber	"Refer to the comment in Number * " 	aNumber isInteger ifTrue:		[^ self digitMultiply: aNumber 					neg: self negative ~~ aNumber negative].	^ aNumber adaptToInteger: self andSend: #*! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!+ aNumber	"Refer to the comment in Number + "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ (self digitAdd: aNumber) normalize]			ifFalse: [^ self digitSubtract: aNumber]].	^ aNumber adaptToInteger: self andSend: #+! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!- aNumber	"Refer to the comment in Number - "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ self digitSubtract: aNumber]			ifFalse: [^ (self digitAdd: aNumber) normalize]].	^ aNumber adaptToInteger: self andSend: #-! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger ifTrue:		[quoRem := self digitDiv: aNumber abs	"*****I've added abs here*****"						neg: self negative ~~ aNumber negative.		(quoRem at: 2) = 0			ifTrue: [^ (quoRem at: 1) normalize]			ifFalse: [^ (Fraction numerator: self denominator: aNumber) reduced]].	^ aNumber adaptToInteger: self andSend: #/! !!Integer methodsFor: 'arithmetic' stamp: 'RAH 4/25/2000 19:49'!// aNumber 	| q |	#Numeric.	"Changed 200/01/19 For ANSI support."	aNumber = 0 ifTrue: [^ (ZeroDivide dividend: self) signal"<- Chg"].	self = 0 ifTrue: [^ 0].	q := self quo: aNumber.	"Refer to the comment in Number|//."	(q negative		ifTrue: [q * aNumber ~= self]		ifFalse: [q = 0 and: [self negative ~= aNumber negative]])		ifTrue: [^ q - 1"Truncate towards minus infinity."]		ifFalse: [^ q]! !!Integer methodsFor: 'arithmetic' stamp: 'hh 8/4/2000 00:39'!\\\ anInteger 	"a modulo method for use in DSA. Be careful if you try to use this elsewhere"	^self \\ anInteger! !!Integer methodsFor: 'arithmetic'!alignedTo: anInteger	"Answer the smallest number not less than receiver that is a multiple of anInteger."	^(self+anInteger-1//anInteger)*anInteger"5 alignedTo: 2""12 alignedTo: 3"! !!Integer methodsFor: 'arithmetic' stamp: 'mga 5/11/2006 15:42'!crossSumBase: aBase	|aResult|	"Precondition"	self assert:[aBase isInteger and: [aBase >=2]].	self < 0 ifTrue: [^self negated crossSumBase: aBase].	self < aBase ifTrue: [^ self].	aResult := self \\ aBase + (self // aBase crossSumBase: aBase).	"Postcondition	E.g. 18 crossSumBase: 10 -> 9 => 18\\(10-1) = 0"	self assert: [((aResult \\ (aBase - 1) = 0)) = ((self \\ (aBase - 1)) =0)].	^aResult! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!quo: aNumber 	"Refer to the comment in Number quo: "	| ng quo |	aNumber isInteger ifTrue: 		[ng := self negative == aNumber negative == false.		quo := (self digitDiv:			(aNumber class == SmallInteger				ifTrue: [aNumber abs]				ifFalse: [aNumber])			neg: ng) at: 1.		^ quo normalize].	^ aNumber adaptToInteger: self andSend: #quo:! !!Integer methodsFor: 'benchmarks' stamp: 'jm 11/20/1998 07:06'!benchFib  "Handy send-heavy benchmark"	"(result // seconds to run) = approx calls per second"	" | r t |	  t := Time millisecondsToRun: [r := 26 benchFib].	  (r * 1000) // t"	"138000 on a Mac 8100/100"	^ self < 2		ifTrue: [1] 		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !!Integer methodsFor: 'benchmarks' stamp: 'di 4/11/1999 11:20'!benchmark  "Handy bytecode-heavy benchmark"	"(500000 // time to run) = approx bytecodes per second"	"5000000 // (Time millisecondsToRun: [10 benchmark]) * 1000"	"3059000 on a Mac 8100/100"    | size flags prime k count |    size := 8190.    1 to: self do:        [:iter |        count := 0.        flags := (Array new: size) atAllPut: true.        1 to: size do:            [:i | (flags at: i) ifTrue:                [prime := i+1.                k := i + prime.                [k <= size] whileTrue:                    [flags at: k put: false.                    k := k + prime].                count := count + 1]]].    ^ count! !!Integer methodsFor: 'benchmarks' stamp: 'dwh 11/21/1999 16:40'!tinyBenchmarks	"Report the results of running the two tiny Squeak benchmarks.	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results"	"0 tinyBenchmarks"	"On a 292 MHz G3 Mac: 22727272 bytecodes/sec; 984169 sends/sec"	"On a 400 MHz PII/Win98:  18028169 bytecodes/sec; 1081272 sends/sec"	| t1 t2 r n1 n2 |	n1 := 1.	[t1 := Time millisecondsToRun: [n1 benchmark].	t1 < 1000] whileTrue:[n1 := n1 * 2]. "Note: #benchmark's runtime is about O(n)"	n2 := 28.	[t2 := Time millisecondsToRun: [r := n2 benchFib].	t2 < 1000] whileTrue:[n2 := n2 + 1]. 	"Note: #benchFib's runtime is about O(k^n),		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."	^ ((n1 * 500000 * 1000) // t1) printString, ' bytecodes/sec; ',	  ((r * 1000) // t2) printString, ' sends/sec'! !!Integer methodsFor: 'bit manipulation'!<< shiftAmount  "left shift"	shiftAmount < 0 ifTrue: [self error: 'negative arg'].	^ self bitShift: shiftAmount! !!Integer methodsFor: 'bit manipulation' stamp: 'dwh 8/18/1999 21:57'!>> shiftAmount  "right shift"	shiftAmount < 0 ifTrue: [self error: 'negative arg'].	^ self bitShift: 0 - shiftAmount! !!Integer methodsFor: 'bit manipulation'!allMask: mask 	"Treat the argument as a bit mask. Answer whether all of the bits that 	are 1 in the argument are 1 in the receiver."	^mask = (self bitAnd: mask)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 11/29/2000 14:32'!anyBitOfMagnitudeFrom: start to: stopArg 	"Tests for any magnitude bits in the interval from start to stopArg."	"Primitive fixed in LargeIntegers v1.2. If you have an earlier version 	comment out the primitive call (using this ST method then)."	| magnitude firstDigitIx lastDigitIx rightShift leftShift stop |	<primitive: 'primAnyBitFromTo' module:'LargeIntegers'>	start < 1 | (stopArg < 1)		ifTrue: [^ self error: 'out of range'].	magnitude := self abs.	stop := stopArg min: magnitude highBit.	start > stop		ifTrue: [^ false].	firstDigitIx := start - 1 // 8 + 1.	lastDigitIx := stop - 1 // 8 + 1.	rightShift := (start - 1 \\ 8) negated.	leftShift := 7 - (stop - 1 \\ 8).	firstDigitIx = lastDigitIx		ifTrue: [| digit mask | 			mask := (255 bitShift: rightShift negated)						bitAnd: (255 bitShift: leftShift negated).			digit := magnitude digitAt: firstDigitIx.			^ (digit bitAnd: mask)				~= 0].	((magnitude digitAt: firstDigitIx)			bitShift: rightShift)			~= 0		ifTrue: [^ true].	firstDigitIx + 1		to: lastDigitIx - 1		do: [:ix | (magnitude digitAt: ix)					~= 0				ifTrue: [^ true]].	(((magnitude digitAt: lastDigitIx)			bitShift: leftShift)			bitAnd: 255)			~= 0		ifTrue: [^ true].	^ false! !!Integer methodsFor: 'bit manipulation'!anyMask: mask 	"Treat the argument as a bit mask. Answer whether any of the bits that 	are 1 in the argument are 1 in the receiver."	^0 ~= (self bitAnd: mask)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitAnd: n 	"Answer an Integer whose bits are the logical AND of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitAnd' module:'LargeIntegers'>	norm := n normalize.	^ self		digitLogic: norm		op: #bitAnd:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'nice 3/21/2008 21:47'!bitAt: anInteger	"Answer 1 if the bit at position anInteger is set to 1, 0 otherwise.	self is considered an infinite sequence of bits, so anInteger can be any strictly positive integer.	Bit at position 1 is the least significant bit.	Negative numbers are in two-complements.		This is a naive implementation that can be refined in subclass for speed"		^(self bitShift: 1 - anInteger) bitAnd: 1! !!Integer methodsFor: 'bit manipulation' stamp: 'nice 2/16/2010 10:07'!bitAt: anInteger put: value	"Answer a new Integer that has the bit of rank anInteger set to value.	The bit value should be 0 or 1, otherwise raise an Error.	The bits are indexed starting at 1 for the least significant bit.	For negative integers, operate on 2-complement representation."		| b |	b := self bitAt: anInteger.	b = value ifTrue: [^self].	0 = value ifTrue: [^self bitAnd: (1 bitShift: anInteger - 1) bitInvert].	1 = value ifTrue: [^self bitOr: (1 bitShift: anInteger - 1)].	self error: 'bit value should be 0 or 1'! !!Integer methodsFor: 'bit manipulation' stamp: 'di 4/30/1998 10:32'!bitClear: aMask 	"Answer an Integer equal to the receiver, except with all bits cleared that are set in aMask."	^ (self bitOr: aMask) - aMask! !!Integer methodsFor: 'bit manipulation' stamp: 'wb 4/28/1998 12:17'!bitInvert	"Answer an Integer whose bits are the logical negation of the receiver's bits.	Numbers are interpreted as having 2's-complement representation."	^ -1 - self! !!Integer methodsFor: 'bit manipulation'!bitInvert32	"Answer the 32-bit complement of the receiver."	^ self bitXor: 16rFFFFFFFF! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitOr: n 	"Answer an Integer whose bits are the logical OR of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitOr' module:'LargeIntegers'>	norm := n normalize.	^ self		digitLogic: norm		op: #bitOr:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/9/2000 10:09'!bitShift: shiftCount 	"Answer an Integer whose value (in twos-complement representation) is  	the receiver's value (in twos-complement representation) shifted left by 	the number of bits indicated by the argument. Negative arguments  	shift right. Zeros are shifted in from the right in left shifts."	| magnitudeShift |	magnitudeShift := self bitShiftMagnitude: shiftCount.	^ ((self negative and: [shiftCount negative])		and: [self anyBitOfMagnitudeFrom: 1 to: shiftCount negated])		ifTrue: [magnitudeShift - 1]		ifFalse: [magnitudeShift]! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/9/2000 14:02'!bitShiftMagnitude: shiftCount 	"Answer an Integer whose value (in magnitude representation) is  	the receiver's value (in magnitude representation) shifted left by  	the number of bits indicated by the argument. Negative arguments	shift right. Zeros are shifted in from the right in left shifts."	| rShift |	<primitive: 'primDigitBitShiftMagnitude' module:'LargeIntegers'>	shiftCount >= 0 ifTrue: [^ self digitLshift: shiftCount].	rShift := 0 - shiftCount.	^ (self		digitRshift: (rShift bitAnd: 7)		bytes: (rShift bitShift: -3)		lookfirst: self digitLength) normalize! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitXor: n 	"Answer an Integer whose bits are the logical XOR of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitXor' module:'LargeIntegers'>	norm := n normalize.	^ self		digitLogic: norm		op: #bitXor:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:13'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self subclassResponsibility! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 01:55'!highBitOfMagnitude	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero."	^ self subclassResponsibility! !!Integer methodsFor: 'bit manipulation' stamp: 'jm 2/19/98 12:11'!lowBit	"Answer the index of the low order bit of this number."	| index |	self = 0 ifTrue: [ ^ 0 ].	index := 1.	[ (self digitAt: index) = 0 ]		whileTrue:			[ index := index + 1 ].	^ (self digitAt: index) lowBit + (8 * (index - 1))! !!Integer methodsFor: 'bit manipulation'!noMask: mask 	"Treat the argument as a bit mask. Answer whether none of the bits that 	are 1 in the argument are 1 in the receiver."	^0 = (self bitAnd: mask)! !!Integer methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:38'!< aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^ (self digitCompare: aNumber) > 0]						ifFalse: [^ (self digitCompare: aNumber) < 0]]			ifFalse: [^ self negative]].	^ aNumber adaptToInteger: self andCompare: #<! !!Integer methodsFor: 'comparing' stamp: 'nice 2/13/2010 04:03'!<= aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^ (self digitCompare: aNumber) >= 0]						ifFalse: [^ (self digitCompare: aNumber) <= 0]]			ifFalse: [^ self negative]].	^ aNumber adaptToInteger: self andCompare: #<=! !!Integer methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:41'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isInteger ifTrue:		[aNumber negative == self negative			ifTrue: [^ (self digitCompare: aNumber) = 0]			ifFalse: [^ false]].	^ aNumber adaptToInteger: self andCompare: #=! !!Integer methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:38'!> aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^(self digitCompare: aNumber) < 0]						ifFalse: [^(self digitCompare: aNumber) > 0]]			ifFalse: [^ aNumber negative]].	^ aNumber adaptToInteger: self andCompare: #>! !!Integer methodsFor: 'comparing' stamp: 'nice 2/13/2010 04:03'!>= aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^(self digitCompare: aNumber) <= 0]						ifFalse: [^(self digitCompare: aNumber) >= 0]]			ifFalse: [^ aNumber negative]].	^ aNumber adaptToInteger: self andCompare: #>=! !!Integer methodsFor: 'comparing'!hash	"Hash is reimplemented because = is implemented."	^(self lastDigit bitShift: 8) + (self digitAt: 1)! !!Integer methodsFor: 'comparing' stamp: 'YG 2/9/2012 16:28'!length	"Get the number of digits in the receiver."	|sum x|	x := self.	sum := 1.	[(x abs) <10] whileFalse: [		x := x / 10.		sum := sum + 1.	].	^sum	! !!Integer methodsFor: 'converting' stamp: 'mk 10/27/2003 17:45'!adaptToComplex: rcvr andSend: selector	"If I am involved in arithmetic with a Complex number, convert me to a Complex number."	^ rcvr perform: selector with: self asComplex! !!Integer methodsFor: 'converting' stamp: 'di 11/6/1998 13:43'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert me to a Fraction."	^ rcvr perform: selector with: self asFraction! !!Integer methodsFor: 'converting' stamp: 'RAH 4/25/2000 19:49'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Convert me to a ScaledDecimal and do the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."	#Numeric.	"add 200/01/19 For ScaledDecimal support."	^ receiverScaledDecimal perform: arithmeticOpSelector with: (self asScaledDecimal: 0)! !!Integer methodsFor: 'converting' stamp: 'ar 4/9/2005 22:31'!asCharacter	"Answer the Character whose value is the receiver."	^Character value: self! !!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04'!asColorOfDepth: d	"Return a color value representing the receiver as color of the given depth"	^Color colorFromPixelValue: self depth: d! !!Integer methodsFor: 'converting' stamp: 'mk 10/27/2003 17:44'!asComplex	"Answer a Complex number that represents value of the the receiver."	^ Complex real: self imaginary: 0! !!Integer methodsFor: 'converting' stamp: 'nice 7/8/2006 01:05'!asFloat	"Answer a Float that represents the value of the receiver.	Optimized to process only the significant digits of a LargeInteger.	SqR: 11/30/1998 21:1		This algorithm does honour IEEE 754 round to nearest even mode.	Numbers are first rounded on nearest integer on 53 bits.	In case of exact half difference between two consecutive integers (2r0.1),	there are two possible choices (two integers are as near, 0 and 1)	In this case, the nearest even integer is chosen.	examples (with less than 53bits for clarity)	2r0.00001 is rounded to 2r0	2r1.00001 is rounded to 2.1	2r0.1 is rounded to 2r0 (nearest event)	2r1.1 is rounded to 2.10 (neraest even)	2r0.10001 is rounded to 2r1	2r1.10001 is rounded to 2.10"		| abs shift sum delta mask trailingBits carry |	self isZero		ifTrue: [^ 0.0].	abs := self abs.	"Assume Float is a double precision IEEE 754 number with 53bits mantissa.	We should better use some Float class message for that (Float precision)..."	delta := abs highBit - 53.	delta > 0		ifTrue: [mask := (1 bitShift: delta) - 1.			trailingBits := abs bitAnd: mask.			"inexact := trailingBits isZero not."			carry := trailingBits bitShift: 1 - delta.			abs := abs bitShift: delta negated.			shift := delta.			(carry isZero					or: [(trailingBits bitAnd: (mask bitShift: -1)) isZero							and: [abs even]])				ifFalse: [abs := abs + 1]]		ifFalse: [shift := 0].		"now, abs has no more than 53 bits, we can do exact floating point arithmetic"	sum := 0.0.	1 to: abs size do:		[:byteIndex | 		sum := ((abs digitAt: byteIndex) asFloat timesTwoPower: shift) + sum.		shift := shift + 8].	^ self positive			ifTrue: [sum]			ifFalse: [sum negated]! !!Integer methodsFor: 'converting'!asFraction	"Answer a Fraction that represents value of the the receiver."	^Fraction numerator: self denominator: 1! !!Integer methodsFor: 'converting' stamp: 'ls 5/26/1998 20:53'!asHexDigit	^'0123456789ABCDEF' at: self+1! !!Integer methodsFor: 'converting'!asInteger	"Answer with the receiver itself."	^self! !!Integer methodsFor: 'converting' stamp: 'nice 2/13/2010 22:46'!asScaledDecimal	"The number of significant digits of the answer is the same as the number of decimal digits in the receiver."	^ ScaledDecimal newFromNumber: self scale: 0! !!Integer methodsFor: 'converting' stamp: 'brp 5/13/2003 10:12'!asYear
	^ Year year: self 
! !!Integer methodsFor: 'enumerating'!timesRepeat: aBlock 	"Evaluate the argument, aBlock, the number of times represented by the 	receiver."	| count |	count := 1.	[count <= self]		whileTrue: 			[aBlock value.			count := count + 1]! !!Integer methodsFor: 'mathematical functions' stamp: 'di 4/22/1998 14:45'!factorial	"Answer the factorial of the receiver."	self = 0 ifTrue: [^ 1].	self > 0 ifTrue: [^ self * (self - 1) factorial].	self error: 'Not valid for negative integers'! !!Integer methodsFor: 'mathematical functions' stamp: 'LC 6/17/1998 19:22'!gcd: anInteger	"See Knuth, Vol 2, 4.5.2, Algorithm L"	"Initialize"	| higher u v k uHat vHat a b c d vPrime vPrimePrime q t |	higher := SmallInteger maxVal highBit.	u := self abs max: (v := anInteger abs).	v := self abs min: v.	[v class == SmallInteger]		whileFalse: 			[(uHat := u bitShift: (k := higher - u highBit)) class == SmallInteger				ifFalse: 					[k := k - 1.					uHat := uHat bitShift: -1].			vHat := v bitShift: k.			a := 1.			b := 0.			c := 0.			d := 1.			"Test quotient"			[(vPrime := vHat + d) ~= 0				and: [(vPrimePrime := vHat + c) ~= 0 and: [(q := uHat + a // vPrimePrime) = (uHat + b // vPrime)]]]				whileTrue: 					["Emulate Euclid"					c := a - (q * (a := c)).					d := b - (q * (b := d)).					vHat := uHat - (q * (uHat := vHat))].			"Multiprecision step"			b = 0				ifTrue: 					[v := u rem: (u := v)]				ifFalse: 					[t := u * a + (v * b).					v := u * c + (v * d).					u := t]].	^ v gcd: u! !!Integer methodsFor: 'mathematical functions'!lcm: n 	"Answer the least common multiple of the receiver and n."	^self // (self gcd: n) * n! !!Integer methodsFor: 'mathematical functions' stamp: 'es 5/25/2005 11:04'!raisedToInteger: exp modulo: m	(exp = 0) ifTrue: [^ 1].	exp even		ifTrue: [^ (self raisedToInteger: (exp // 2) modulo: m) squared \\ m]		ifFalse: [^ (self * (self raisedToInteger: (exp - 1) modulo: m)) \\ m].! !!Integer methodsFor: 'mathematical functions' stamp: 'hh 8/4/2000 01:09'!raisedTo: y modulo: n	"Answer the modular exponential. Code by Jesse Welton."	| s t u |	s := 1.	t := self.	u := y.	[u = 0] whileFalse: [		u odd ifTrue: [			s := s * t.			s >= n ifTrue: [s := s \\\ n]].		t := t * t.		t >= n ifTrue: [t := t \\\ n].		u := u bitShift: -1].	^ s! !!Integer methodsFor: 'mathematical functions' stamp: 'ul 11/25/2009 02:34'!sqrtFloor	"Return the integer part of the square root of self"	| guess guessSquared delta |	guess := 1 bitShift: self highBit + 1 // 2.	[		guessSquared := guess * guess.		delta := guessSquared - self // (guess bitShift: 1).		delta = 0 ] whileFalse: [			guess := guess - delta ].	guessSquared = self ifFalse: [ guess := guess - 1 ].	^guess! !!Integer methodsFor: 'mathematical functions' stamp: 'tk 7/30/97 13:08'!take: kk	"Return the number of combinations of (self) elements taken kk at a time.  For 6 take 3, this is 6*5*4 / (1*2*3).  Zero outside of Pascal's triangle.  Use a trick to go faster."	" 6 take: 3  "	| num denom |	kk < 0 ifTrue: [^ 0].	kk > self ifTrue: [^ 0].	num := 1.	self to: (kk max: self-kk) + 1 by: -1 do: [:factor | num := num * factor].	denom := 1.	1 to: (kk min: self-kk) do: [:factor | denom := denom * factor].	^ num // denom! !!Integer methodsFor: 'printing' stamp: 'YG 2/9/2012 15:45'!, anObj	"print integer with strings"	^ self asString , anObj asString! !!Integer methodsFor: 'printing' stamp: 'sw 11/24/1998 14:53'!asStringWithCommas	"123456789 asStringWithCommas"	"-123456789 asStringWithCommas"	| digits |	digits := self abs printString.	^ String streamContents:		[:strm | 		self sign = -1 ifTrue: [strm nextPut: $-].		1 to: digits size do: 			[:i | strm nextPut: (digits at: i).			(i < digits size and: [(i - digits size) \\ 3 = 0])				ifTrue: [strm nextPut: $,]]]! !!Integer methodsFor: 'printing' stamp: 'ar 7/18/2001 22:09'!asStringWithCommasSigned	"123456789 asStringWithCommasSigned"	"-123456789 asStringWithCommasSigned"	| digits |	digits := self abs printString.	^ String streamContents:		[:strm | 		self sign = -1 ifTrue: [strm nextPut: $-] ifFalse:[strm nextPut: $+].		1 to: digits size do: 			[:i | strm nextPut: (digits at: i).			(i < digits size and: [(i - digits size) \\ 3 = 0])				ifTrue: [strm nextPut: $,]]]! !!Integer methodsFor: 'printing' stamp: 'sw 11/13/1999 23:00'!asTwoCharacterString	"Answer a two-character string representing the receiver, with leading zero if required.  Intended for use with integers in the range 0 to 99, but plausible replies given for other values too"	^ (self >= 0 and: [self < 10])		ifTrue:	['0', self printString]		ifFalse:	[self printString copyFrom: 1 to: 2]"2 asTwoCharacterString11 asTwoCharacterString1943 asTwoCharacterString0 asTwoCharacterString-2 asTwoCharacterString-234 asTwoCharacterString"! !!Integer methodsFor: 'printing' stamp: 'tk 4/1/2002 11:30'!asWords	"SmallInteger maxVal asWords"	| mils minus three num answer milCount |	self = 0 ifTrue: [^'zero'].	mils := #('' ' thousand' ' million' ' billion' ' trillion' ' quadrillion' ' quintillion' ' sextillion' ' septillion' ' octillion' ' nonillion' ' decillion' ' undecillion' ' duodecillion' ' tredecillion' ' quattuordecillion' ' quindecillion' ' sexdecillion' ' septendecillion' ' octodecillion' ' novemdecillion' ' vigintillion').	num := self.	minus := ''.	self < 0 ifTrue: [		minus := 'negative '.		num := num negated.	].	answer := String new.	milCount := 1.	[num > 0] whileTrue: [		three := (num \\ 1000) threeDigitName.		num := num // 1000.		three isEmpty ifFalse: [			answer isEmpty ifFalse: [				answer := ', ',answer			].			answer := three,(mils at: milCount),answer.		].		milCount := milCount + 1.	].	^minus,answer! !!Integer methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:14'!destinationBuffer:digitLength  digitLength <= 1		ifTrue: [self]		ifFalse: [LargePositiveInteger new: digitLength].! !!Integer methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:16'!digitBuffer:digitLength  ^Array new:digitLength*8.! !!Integer methodsFor: 'printing' stamp: 'JPF 6/26/2007 21:11'!hex"receiver is in range 0 to 255. Returns a two 'digit' hexadecimal representation of the receiver.If you want no padding use asHexDigit or printStringHex. i.e.     15 printStringHex ==  'F'     15 asHexDigit == $F     15 hex == '0F'"^self printStringBase: 16 length: 2 padded: true! !!Integer methodsFor: 'printing'!isLiteral	^true! !!Integer methodsFor: 'printing' stamp: 'nice 2/15/2008 22:14'!numberOfDigitsInBase: b 	"Return how many digits are necessary to print this number in base b.	This does not count any place for minus sign, radix prefix or whatever.	Note that this algorithm may cost a few operations on LargeInteger."	| nDigits q |	self negative ifTrue: [^self negated numberOfDigitsInBase: b].	self < b ifTrue: [^1].	b isPowerOfTwo	ifTrue: [^self highBit + b highBit - 2 quo: b highBit - 1].		"A conversion from base 2 to base b has to be performed.	This algorithm avoids Float computations like (self log: b) floor + 1,	1) because they are inexact	2) because LargeInteger might overflow	3) because this algorithm might be cheaper than conversion"	"Make an initial nDigits guess that is lower than or equal to required number of digits"	b = 10		ifTrue: [nDigits := ((self highBit - 1) * 3 quo: 10) + 1. "This is because 1024 is a little more than a kilo"]		ifFalse: [nDigits := self highBit quo: b highBit].	"See how many digits remains above these first nDigits guess"	q := self quo: (b raisedTo: nDigits).	^q = 0		ifTrue: [nDigits]		ifFalse: [nDigits + (q numberOfDigitsInBase: b)]! !!Integer methodsFor: 'printing' stamp: 'nice 2/15/2008 21:49'!printOn: aStream	^self printOn: aStream base: 10! !!Integer methodsFor: 'printing' stamp: 'fbs 2/9/2006 08:57'!printOn: outputStream base: baseInteger showRadix: flagBoolean 	"Write a sequence of characters that describes the receiver in radix 	baseInteger with optional radix specifier. 	The result is undefined if baseInteger less than 2 or greater than 36."	| tempString startPos |	#Numeric.	"2000/03/04  Harmon R. Added ANSI <integer> protocol"	tempString := self printStringRadix: baseInteger.	flagBoolean ifTrue: [^ outputStream nextPutAll: tempString].	startPos := (tempString indexOf: $r ifAbsent: [self error: 'radix indicator not found.'])				+ 1.	self negative ifTrue: [outputStream nextPut: $-].	outputStream nextPutAll: (tempString copyFrom: startPos to: tempString size)! !!Integer methodsFor: 'printing' stamp: 'RAH 4/25/2000 19:49'!printPaddedWith: aCharacter to: anInteger 	"Answer the string containing the ASCII representation of the receiver 	padded on the left with aCharacter to be at least anInteger characters."	#Numeric.	"2000/03/04  Harmon R. Added Date and Time support"	^ self		printPaddedWith: aCharacter		to: anInteger		base: 10! !!Integer methodsFor: 'printing' stamp: 'md 7/30/2005 21:13'!printPaddedWith: aCharacter to: anInteger base: aRadix 	"Answer the string containing the ASCII representation of the receiver 	padded on the left with aCharacter to be at least anInteger characters."	| aStream padding digits |	#Numeric.	"2000/03/04  Harmon R. Added Date and Time support"	aStream := WriteStream on: (String new: 10).	self		printOn: aStream		base: aRadix		showRadix: false.	digits := aStream contents.	padding := anInteger - digits size.	padding > 0 ifFalse: [^ digits].	^ ((String new: padding) atAllPut: aCharacter;	 yourself) , digits! !!Integer methodsFor: 'printing' stamp: 'nice 2/15/2008 21:49'!printString	"For Integer, prefer the stream version to the string version for efficiency"		^String streamContents: [:str | self printOn: str base: 10]! !!Integer methodsFor: 'printing' stamp: 'md 7/30/2005 21:00'!printStringRadix: baseInteger 	"Return a string containing a sequence of characters that represents the 	numeric value of the receiver in the radix specified by the argument.  	If the receiver is negative, a minus sign ('-') is prepended to the 	sequence of characters. 	The result is undefined if baseInteger less than 2 or greater than 36."	| tempString |	#Numeric.	"2000/03/04  Harmon R. Added ANSI <integer> protocol"	baseInteger = 10		ifTrue: 			[tempString := self storeStringBase: baseInteger.			self negative				ifTrue: [^ '-10r' , (tempString copyFrom: 2 to: tempString size)]				ifFalse: [^ '10r' , tempString]].	^ self storeStringBase: baseInteger! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 1/30/2005 13:53'!byteEncode: aStream base: base	^self printOn: aStream base: base	! !!Integer methodsFor: 'printing-numerative' stamp: 'nice 2/15/2008 21:52'!printOn: aStream base: base	^self subclassResponsibility! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 18:13'!printOn: aStream base: base length: minimum padded: zeroFlag	| prefix |	prefix := self negative ifTrue: ['-'] ifFalse: [String new].	self print: (self abs printStringBase: base) on: aStream prefix: prefix length: minimum padded: zeroFlag! !!Integer methodsFor: 'printing-numerative' stamp: 'nice 2/15/2008 21:44'!printOn: aStream base: b nDigits: n 	"Append a representation of this number in base b on aStream using nDigits.	self must be positive."	self subclassResponsibility! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 18:14'!printStringBase: base length: minimum padded: zeroFlag	^String streamContents: [:s| self printOn: s base: base length: minimum padded: zeroFlag]! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 10:58'!printStringHex	^self printStringBase: 16! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 18:21'!printStringLength: minimal	^self printStringLength: minimal padded: false! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 18:20'!printStringLength: minimal padded: zeroFlag	^self printStringBase: 10 length: minimal padded: zeroFlag! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 18:20'!printStringPadded: minimal	^self printStringLength: minimal padded: true! !!Integer methodsFor: 'printing-numerative' stamp: 'nice 12/13/2009 17:59'!printStringRoman	^String streamContents: [:stream | | integer |		integer := self negative ifTrue: [stream nextPut: $-. self negated] ifFalse: [self].		integer // 1000 timesRepeat: [stream nextPut: $M].		integer			romanDigits: 'MDC' for: 100 on: stream;			romanDigits: 'CLX' for: 10 on: stream;			romanDigits: 'XVI' for: 1 on: stream]! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 13:35'!radix: base 	^ self printStringBase: base! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 13:36'!storeOn: aStream base: base	"Print a representation of the receiver on the stream	<aStream> in base <base> where	2 <= <baseInteger> <= 16. If <base> is other than 10	it is written first separated by $r followed by the number	like for example: 16rFCE2"	| integer |	integer := self negative		ifTrue: [aStream nextPut: $-. self negated]		ifFalse: [self].	base = 10 ifFalse: [aStream nextPutAll: base printString; nextPut: $r].	aStream nextPutAll: (integer printStringBase: base).! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 18:16'!storeOn: aStream base: base length: minimum padded: zeroFlag	| prefix |	prefix := self negative ifTrue: ['-'] ifFalse: [String new].	base = 10 ifFalse: [prefix := prefix, base printString, 'r'].	self print: (self abs printStringBase: base) on: aStream prefix: prefix length: minimum padded: zeroFlag! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 18:16'!storeStringBase: base length: minimum padded: zeroFlag	^String streamContents: [:s| self storeOn: s base: base length: minimum padded: zeroFlag]! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 10:58'!storeStringHex	^self storeStringBase: 16! !!Integer methodsFor: 'system primitives' stamp: 'tk 3/24/1999 20:26'!lastDigit	"Answer the last digit of the integer base 256.  LargePositiveInteger uses bytes of base two number, and each is a 'digit'."	^self digitAt: self digitLength! !!Integer methodsFor: 'system primitives'!replaceFrom: start to: stop with: replacement startingAt: repStart	| j |  "Catches failure if LgInt replace primitive fails"	j := repStart.	start to: stop do:		[:i |		self digitAt: i put: (replacement digitAt: j).		j := j+1]! !!Integer methodsFor: 'testing'!even 	"Refer to the comment in Number|even."	^((self digitAt: 1) bitAnd: 1) = 0! !!Integer methodsFor: 'testing'!isInteger	"True for all subclasses of Integer."	^ true! !!Integer methodsFor: 'testing' stamp: 'ar 6/9/2000 18:56'!isPowerOfTwo	"Return true if the receiver is an integral power of two."	^ (self bitAnd: self-1) = 0! !!Integer methodsFor: 'testing' stamp: 'dtl 1/23/2010 14:16'!isPrime	"Answer true if the receiver is a prime number. See isProbablyPrime for a probabilistic	implementation that is much faster for large integers, and that is correct to an extremely	high statistical level of confidence (effectively deterministic)."		self <= 1 ifTrue: [ ^false ].	self even ifTrue: [ ^self = 2].	3 to: self sqrtFloor by: 2 do: [ :each |		self \\ each = 0 ifTrue: [ ^false ] ].	^true! !!Integer methodsFor: 'testing' stamp: 'ul 11/25/2009 02:28'!isProbablyPrime	"See isProbablyPrimeWithK:andQ: for the algoritm description."		| k q |	self <= 1 ifTrue: [ ^false ].	self even ifTrue: [ ^self = 2 ].	k := 1.	q := self - 1 bitShift: -1.	[ q odd ] whileFalse: [		q := q bitShift: -1.		k := k + 1 ].	25 timesRepeat: [ (self isProbablyPrimeWithK: k andQ: q) ifFalse: [ ^false ] ].	^true! !!Integer methodsFor: 'tiles' stamp: 'RAA 8/24/1999 15:32'!asPrecedenceName	^#('unary' 'binary' 'keyword') at: self! !!Integer methodsFor: 'truncation and round off' stamp: 'ar 6/9/2000 19:16'!asLargerPowerOfTwo	"Convert the receiver into a power of two which is not less than the receiver"	self isPowerOfTwo		ifTrue:[^self]		ifFalse:[^1 bitShift: (self highBit)]! !!Integer methodsFor: 'truncation and round off' stamp: 'ar 6/9/2000 18:56'!asPowerOfTwo	"Convert the receiver into a power of two"	^self asSmallerPowerOfTwo! !!Integer methodsFor: 'truncation and round off' stamp: 'ar 6/9/2000 19:16'!asSmallerPowerOfTwo	"Convert the receiver into a power of two which is not larger than the receiver"	self isPowerOfTwo		ifTrue:[^self]		ifFalse:[^1 bitShift: (self highBit - 1)]! !!Integer methodsFor: 'truncation and round off' stamp: 'lr 11/4/2003 12:14'!atRandom	"Answer a random integer from 1 to self.  This implementation uses a	shared generator. Heavy users should their own implementation or use	Interval>atRandom: directly."	self = 0 ifTrue: [ ^0 ].	self < 0 ifTrue: [ ^self negated atRandom negated ].	^Collection mutexForPicking critical: [		self atRandom: Collection randomForPicking ]! !!Integer methodsFor: 'truncation and round off' stamp: 'sma 5/12/2000 12:35'!atRandom: aGenerator	"Answer a random integer from 1 to self picked from aGenerator."	^ aGenerator nextInt: self! !!Integer methodsFor: 'truncation and round off'!ceiling 	"Refer to the comment in Number|ceiling."! !!Integer methodsFor: 'truncation and round off'!floor 	"Refer to the comment in Number|floor."! !!Integer methodsFor: 'truncation and round off'!normalize 	"SmallInts OK; LgInts override"	^ self! !!Integer methodsFor: 'truncation and round off'!rounded 	"Refer to the comment in Number|rounded."! !!Integer methodsFor: 'truncation and round off'!truncated 	"Refer to the comment in Number|truncated."! !!Integer methodsFor: 'private'!copyto: x	| stop |	stop := self digitLength min: x digitLength.	^ x replaceFrom: 1 to: stop with: self startingAt: 1! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:41'!digitAdd: arg 	| len arglen accum sum |	<primitive: 'primDigitAdd' module:'LargeIntegers'>	accum := 0.	(len := self digitLength) < (arglen := arg digitLength) ifTrue: [len := arglen].	"Open code max: for speed"	sum := Integer new: len neg: self negative.	1 to: len do: 		[:i | 		accum := (accum bitShift: -8)					+ (self digitAt: i) + (arg digitAt: i).		sum digitAt: i put: (accum bitAnd: 255)].	accum > 255		ifTrue: 			[sum := sum growby: 1.			sum at: sum digitLength put: (accum bitShift: -8)].	^ sum! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:43'!digitCompare: arg 	"Compare the magnitude of self with that of arg.   	Return a code of 1, 0, -1 for self >, = , < arg"	| len arglen argDigit selfDigit |	<primitive: 'primDigitCompare' module:'LargeIntegers'>	len := self digitLength.	(arglen := arg digitLength) ~= len		ifTrue: [arglen > len				ifTrue: [^ -1]				ifFalse: [^ 1]].	[len > 0]		whileTrue: 			[(argDigit := arg digitAt: len) ~= (selfDigit := self digitAt: len)				ifTrue: [argDigit < selfDigit						ifTrue: [^ 1]						ifFalse: [^ -1]].			len := len - 1].	^ 0! !!Integer methodsFor: 'private' stamp: 'sr 6/8/2000 01:28'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	<primitive: 'primDigitDivNegative' module:'LargeIntegers'>	arg = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	"TFEI added this line"	l := self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^ Array with: 0 with: self].	"shortcut against #highBit"	d := 8 - arg lastDigit highBitOfPositiveReceiver.	div := arg digitLshift: d.	div := div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem := self digitLshift: d.	rem digitLength = self digitLength ifTrue: [rem := rem growto: self digitLength + 1].	"makes a copy and shifts"	quo := Integer new: l neg: ng.	dl := div digitLength - 1.	"Last actual byte of data"	ql := l.	dh := div digitAt: dl.	dnh := dl = 1				ifTrue: [0]				ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j := rem digitLength + 1 - k.		"r1 := rem digitAt: j."		(rem digitAt: j)			= dh			ifTrue: [qhi := qlo := 15				"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13  				bits."				"r2 := (rem digitAt: j - 1)."				t := ((rem digitAt: j)							bitShift: 4)							+ ((rem digitAt: j - 1)									bitShift: -4).				qhi := t // dh.				t := (t \\ dh bitShift: 4)							+ ((rem digitAt: j - 1)									bitAnd: 15).				qlo := t // dh.				t := t \\ dh.				"Next compute (hi,lo) := q*dnh"				hi := qhi * dnh.				lo := qlo * dnh + ((hi bitAnd: 15)								bitShift: 4).				hi := (hi bitShift: -4)							+ (lo bitShift: -8).				lo := lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 := j < 3							ifTrue: [0]							ifFalse: [rem digitAt: j - 2].				[(t < hi					or: [t = hi and: [r3 < lo]])					and: 						["i.e. (t,r3) < (hi,lo)"						qlo := qlo - 1.						lo := lo - dnh.						lo < 0							ifTrue: 								[hi := hi - 1.								lo := lo + 256].						hi >= dh]]					whileTrue: [hi := hi - dh].				qlo < 0					ifTrue: 						[qhi := qhi - 1.						qlo := qlo + 16]].		"Subtract q*div from rem"		l := j - dl.		a := 0.		1 to: div digitLength do: 			[:i | 			hi := (div digitAt: i)						* qhi.			lo := a + (rem digitAt: l) - ((hi bitAnd: 15)							bitShift: 4) - ((div digitAt: i)							* qlo).			rem digitAt: l put: lo - (lo // 256 * 256).			"sign-tolerant form of (lo bitAnd: 255)"			a := lo // 256 - (hi bitShift: -4).			l := l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				qlo := qlo - 1.				l := j - dl.				a := 0.				1 to: div digitLength do: 					[:i | 					a := (a bitShift: -8)								+ (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l := l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4)				+ qlo].	rem := rem				digitRshift: d				bytes: 0				lookfirst: dl.	^ Array with: quo with: rem! !!Integer methodsFor: 'private' stamp: 'nice 1/26/2008 02:12'!digitLogic: arg op: op length: len 	| i result neg1 neg2 rneg z1 z2 rz b1 b2 b |	neg1 := self negative.	neg2 := arg negative.	rneg := ((neg1				ifTrue: [-1]				ifFalse: [0])				perform: op				with: (neg2						ifTrue: [-1]						ifFalse: [0]))				< 0.	result := Integer new: len neg: rneg.	rz := z1 := z2 := true.	i := 0.	[(i := i + 1) <= len		or: ["mind a carry on result that might go past len digits"			rneg and: [rz				and: [result := result growby: 1.					true]]]]		whileTrue: [b1 := self digitAt: i.			neg1				ifTrue: [b1 := z1								ifTrue: [b1 = 0										ifTrue: [0]										ifFalse: [z1 := false.											256 - b1]]								ifFalse: [255 - b1]].			b2 := arg digitAt: i.			neg2				ifTrue: [b2 := z2								ifTrue: [b2 = 0										ifTrue: [0]										ifFalse: [z2 := false.											256 - b2]]								ifFalse: [255 - b2]].			b := b1 perform: op with: b2.			result				digitAt: i				put: (rneg						ifTrue: [rz								ifTrue: [b = 0										ifTrue: [0]										ifFalse: [rz := false.											256 - b]]								ifFalse: [255 - b]]						ifFalse: [b])].	^ result normalize! !!Integer methodsFor: 'private' stamp: 'sr 6/8/2000 01:30'!digitLshift: shiftCount 	| carry rShift mask len result digit byteShift bitShift highBit |	(highBit := self highBitOfMagnitude) = 0 ifTrue: [^ 0].	len := highBit + shiftCount + 7 // 8.	result := Integer new: len neg: self negative.	byteShift := shiftCount // 8.	bitShift := shiftCount \\ 8.	bitShift = 0 ifTrue: ["Fast version for byte-aligned shifts"		^ result			replaceFrom: byteShift + 1			to: len			with: self			startingAt: 1].	carry := 0.	rShift := bitShift - 8.	mask := 255 bitShift: 0 - bitShift.	1 to: byteShift do: [:i | result digitAt: i put: 0].	1 to: len - byteShift do: 		[:i | 		digit := self digitAt: i.		result digitAt: i + byteShift put: (((digit bitAnd: mask)				bitShift: bitShift)				bitOr: carry).		carry := digit bitShift: rShift].	^ result! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:46'!digitMultiply: arg neg: ng 	| prod prodLen carry digit k ab |	<primitive: 'primDigitMultiplyNegative' module:'LargeIntegers'>	(arg digitLength = 1 and: [(arg digitAt: 1)			= 0])		ifTrue: [^ 0].	(self digitLength = 1 and: [(self digitAt: 1)			= 0])		ifTrue: [^ 0].	prodLen := self digitLength + arg digitLength.	prod := Integer new: prodLen neg: ng.	"prod starts out all zero"	1 to: self digitLength do: [:i | (digit := self digitAt: i) ~= 0			ifTrue: 				[k := i.				carry := 0.				"Loop invariant: 0<=carry<=0377, k=i+j-1"				1 to: arg digitLength do: 					[:j | 					ab := (arg digitAt: j)								* digit + carry + (prod digitAt: k).					carry := ab bitShift: -8.					prod digitAt: k put: (ab bitAnd: 255).					k := k + 1].				prod digitAt: k put: carry]].	^ prod normalize! !!Integer methodsFor: 'private'!digitRshift: anInteger bytes: b lookfirst: a 	 "Shift right 8*b+anInteger bits, 0<=n<8.	Discard all digits beyond a, and all zeroes at or below a."	| n x r f m digit count i |	n := 0 - anInteger.	x := 0.	f := n + 8.	i := a.	m := 255 bitShift: 0 - f.	digit := self digitAt: i.	[((digit bitShift: n) bitOr: x) = 0 and: [i ~= 1]] whileTrue:		[x := digit bitShift: f "Can't exceed 8 bits".		i := i - 1.		digit := self digitAt: i].	i <= b ifTrue: [^Integer new: 0 neg: self negative].  "All bits lost"	r := Integer new: i - b neg: self negative.	count := i.	x := (self digitAt: b + 1) bitShift: n.	b + 1 to: count do:		[:j | digit := self digitAt: j + 1.		r digitAt: j - b put: (((digit bitAnd: m) bitShift: f) bitOr: x) 			"Avoid values > 8 bits".		x := digit bitShift: n].	^r! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:46'!digitSubtract: arg 	| smaller larger z sum sl al ng |	<primitive: 'primDigitSubtract' module:'LargeIntegers'>	sl := self digitLength.	al := arg digitLength.	(sl = al		ifTrue: 			[[(self digitAt: sl)				= (arg digitAt: sl) and: [sl > 1]]				whileTrue: [sl := sl - 1].			al := sl.			(self digitAt: sl)				< (arg digitAt: sl)]		ifFalse: [sl < al])		ifTrue: 			[larger := arg.			smaller := self.			ng := self negative == false.			sl := al]		ifFalse: 			[larger := self.			smaller := arg.			ng := self negative].	sum := Integer new: sl neg: ng.	z := 0.	"Loop invariant is -1<=z<=1"	1 to: sl do: 		[:i | 		z := z + (larger digitAt: i) - (smaller digitAt: i).		sum digitAt: i put: z - (z // 256 * 256).		"sign-tolerant form of (z bitAnd: 255)"		z := z // 256].	^ sum normalize! !!Integer methodsFor: 'private'!growby: n	^self growto: self digitLength + n! !!Integer methodsFor: 'private'!growto: n	^self copyto: (self species new: n)! !!Integer methodsFor: 'private' stamp: 'es 5/31/2005 09:30'!isProbablyPrimeWithK: k andQ: q 	"Algorithm P, probabilistic primality test, from	Knuth, Donald E. 'The Art of Computer Programming', Vol 2,	Third Edition, section 4.5.4, page 395, P1-P5 refer to Knuth description."	"P1"	| x j y |	x := (self - 2) atRandom + 1.	"P2"	j := 0.	y := x raisedToInteger: q modulo: self.	"P3"		[(((j = 0) & (y = 1)) | (y = (self - 1))) ifTrue: [^true].	((j > 0) & (y = 1)) ifTrue: [^false].	"P5"	true]  			whileTrue: 				[j := j + 1.				(j < k) ifTrue: [y := y squared \\ self]				ifFalse:[^ false]]! !!Integer methodsFor: 'private' stamp: 'laza 3/29/2004 18:16'!print: positiveNumberString on: aStream prefix: prefix length: minimum padded: zeroFlag	| padLength |	padLength := minimum - positiveNumberString size - prefix size.	padLength > 0		ifTrue: [zeroFlag				ifTrue: [aStream nextPutAll: prefix; nextPutAll: (String new: padLength withAll: $0)]				ifFalse: [aStream nextPutAll: (String new: padLength withAll: Character space); nextPutAll: prefix]]		ifFalse: [aStream nextPutAll: prefix].	aStream nextPutAll: positiveNumberString	! !!Integer methodsFor: 'private' stamp: 'sma 5/20/2000 17:00'!romanDigits: digits for: base on: aStream	| n |	n := self \\ (base * 10) // base.	n = 9 ifTrue: [^ aStream nextPut: digits last; nextPut: digits first].	n = 4 ifTrue: [^ aStream nextPut: digits last; nextPut: digits second].	n > 4 ifTrue: [aStream nextPut: digits second].	n \\ 5 timesRepeat: [aStream nextPut: digits last]! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionEqual: anObject	^anObject isInteger and: [ self = anObject ]! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionLessThan: anObject	^anObject isInteger and: [ self < anObject ]! !!Integer methodsFor: '*Morphic-Explorer' stamp: 'ul 11/11/2009 19:47'!explorerContents	^#(		('hexadecimal' 16)		('octal' 8)		('binary' 2)) collect: [ :each |			ObjectExplorerWrapper				with: each first translated				name: (self printStringBase: each second)				model: self ]! !!Integer methodsFor: '*Morphic-Explorer' stamp: 'laza 3/17/2005 13:38'!hasContentsInExplorer	^true! !!Integer methodsFor: '*files' stamp: 'cmm 2/15/2010 15:52'!asBytesDescription	"Answer a terse, easily-readable representation of this Integer reprsenting a number of bytes.  Useful for file-browsers."	| suffixes |	suffixes := { 'k'"ilobytes". 'M'"egabytes". 'G'"igabytes". 'T'"erabytes". 'P'"etabytes". 'E'"xabytes". 'Z'"ettabytes". 'Y'"ottabytes"}.	suffixes size to: 1 by: -1 do:		[ : index |  | units |		units := 1000 raisedTo: index.		self > units ifTrue: [ ^ ((self / units) asFloat roundTo: 0.01) asString, (suffixes at: index) ] ].	^ self asString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Integer class	instanceVariableNames: ''!!Integer class methodsFor: 'compatibility' stamp: 'laza 10/16/2004 14:34'!readFrom: aStream radix: radix	^self readFrom: aStream base: radix! !!Integer class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:18'!basicNew	self == Integer ifTrue: [		^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].	^ super basicNew! !!Integer class methodsFor: 'instance creation' stamp: 'bf 2/2/2004 00:23'!byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4 	"Depending on high-order byte copy directly into a LargeInteger,	or build up a SmallInteger by shifting"	| value |	byte4 < 16r40 ifTrue:		[^ (byte4 bitShift: 24)		 + (byte3 bitShift: 16)		 + (byte2 bitShift: 8)		 + byte1].	value := LargePositiveInteger new: 4.	value digitAt: 4 put: byte4.	value digitAt: 3 put: byte3.	value digitAt: 2 put: byte2.	value digitAt: 1 put: byte1.	^ value! !!Integer class methodsFor: 'instance creation' stamp: 'sw 5/8/2000 11:05'!initializedInstance	^ 2468! !!Integer class methodsFor: 'instance creation' stamp: 'tk 4/18/1999 22:01'!new	self == Integer ifTrue: [		^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].	^ super new! !!Integer class methodsFor: 'instance creation'!new: length neg: neg	"Answer an instance of a large integer whose size is length. neg is a flag 	determining whether the integer is negative or not."	neg 		ifTrue: [^LargeNegativeInteger new: length]		ifFalse: [^LargePositiveInteger new: length]! !!Integer class methodsFor: 'instance creation' stamp: 'nice 3/15/2008 00:36'!readFrom: aStringOrStream 	"Answer a new Integer as described on the stream, aStream.	Embedded radix specifiers not allowed - use Number readFrom: for that."	^self readFrom: aStringOrStream base: 10! !!Integer class methodsFor: 'instance creation' stamp: 'nice 2/22/2010 23:12'!readFrom: aStringOrStream base: base 	"Answer an instance of one of the concrete subclasses if Integer. 	Initial plus or minus sign accepted, and bases > 10 use letters A-Z.	Imbedded radix specifiers not allowed;  use Number class readFrom: for that.	Raise an Error if there are no digits."	^(ExtendedNumberParser on: aStringOrStream) nextIntegerBase: base! !!Integer class methodsFor: 'instance creation' stamp: 'nice 2/22/2010 23:12'!readFrom: aStringOrStream ifFail: aBlock	"Answer an instance of one of the concrete subclasses if Integer. 	Initial plus or minus sign accepted.	Imbedded radix specifiers not allowed;  use Number class readFrom: for that.	Execute aBlock if there are no digits."	^(ExtendedNumberParser on: aStringOrStream) nextIntegerBase: 10 ifFail: aBlock! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:34'!largePrimesUpTo: maxValue	"Compute and return all the prime numbers up to maxValue"	^Array streamContents:[:s| self largePrimesUpTo: maxValue do:[:prime| s nextPut: prime]]! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 02:38'!largePrimesUpTo: max do: aBlock	"Evaluate aBlock with all primes up to maxValue.	The Algorithm is adapted from http://www.rsok.com/~jrm/printprimes.html	It encodes prime numbers much more compactly than #primesUpTo: 	38.5 integer per byte (2310 numbers per 60 byte) allow for some fun large primes.	(all primes up to SmallInteger maxVal can be computed within ~27MB of memory;	the regular #primesUpTo: would require 4 *GIGA*bytes).	Note: The algorithm could be re-written to produce the first primes (which require	the longest time to sieve) faster but only at the cost of clarity."	| limit flags maskBitIndex bitIndex maskBit byteIndex index primesUpTo2310 indexLimit |	limit := max asInteger - 1.	indexLimit := max sqrt truncated + 1.	"Create the array of flags."	flags := ByteArray new: (limit + 2309) // 2310 * 60 + 60.	flags atAllPut: 16rFF. "set all to true"	"Compute the primes up to 2310"	primesUpTo2310 := self primesUpTo: 2310.	"Create a mapping from 2310 integers to 480 bits (60 byte)"	maskBitIndex := Array new: 2310.	bitIndex := -1. "for pre-increment"	maskBitIndex at: 1 put: (bitIndex := bitIndex + 1).	maskBitIndex at: 2 put: (bitIndex := bitIndex + 1).	1 to: 5 do:[:i| aBlock value: (primesUpTo2310 at: i)].	index := 6.	2 to: 2309 do:[:n|		[(primesUpTo2310 at: index) < n] 			whileTrue:[index := index + 1].		n = (primesUpTo2310 at: index) ifTrue:[			maskBitIndex at: n+1 put: (bitIndex := bitIndex + 1).		] ifFalse:[			"if modulo any of the prime factors of 2310, then could not be prime"			(n \\ 2 = 0 or:[n \\ 3 = 0 or:[n \\ 5 = 0 or:[n \\ 7 = 0 or:[n \\ 11 = 0]]]]) 				ifTrue:[maskBitIndex at: n+1 put: 0]				ifFalse:[maskBitIndex at: n+1 put: (bitIndex := bitIndex + 1)].		].	].	"Now the real work begins...	Start with 13 since multiples of 2,3,5,7,11 are handled by the storage method;	increment by 2 for odd numbers only."	13 to: limit by: 2 do:[:n|		(maskBit := maskBitIndex at: (n \\ 2310 + 1)) = 0 ifFalse:["not a multiple of 2,3,5,7,11"			byteIndex := n // 2310 * 60 + (maskBit-1 bitShift: -3) + 1.			bitIndex := 1 bitShift: (maskBit bitAnd: 7).			((flags at: byteIndex) bitAnd: bitIndex) = 0 ifFalse:["not marked -- n is prime"				aBlock value: n.				"Start with n*n since any integer < n has already been sieved 				(e.g., any multiple of n with a number k < n has been cleared 				when k was sieved); add 2 * i to avoid even numbers and				mark all multiples of this prime. Note: n < indexLimit below				limits running into LargeInts -- nothing more."				n < indexLimit ifTrue:[					index := n * n.					(index bitAnd: 1) = 0 ifTrue:[index := index + n].					[index <= limit] whileTrue:[						(maskBit := maskBitIndex at: (index \\ 2310 + 1)) = 0 ifFalse:[							byteIndex := (index // 2310 * 60) + (maskBit-1 bitShift: -3) + 1.							maskBit := 255 - (1 bitShift: (maskBit bitAnd: 7)).							flags at: byteIndex put: ((flags at: byteIndex) bitAnd: maskBit).						].						index := index + (2 * n)].				].			].		].	].! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:33'!primesUpTo: max	"Return a list of prime integers up to the given integer."	"Integer primesUpTo: 100"	^Array streamContents:[:s| self primesUpTo: max do:[:prime| s nextPut: prime]]! !!Integer class methodsFor: 'prime numbers' stamp: 'md 2/13/2006 14:38'!primesUpTo: max do: aBlock	"Compute aBlock with all prime integers up to the given integer."	"Integer primesUpTo: 100"	| limit flags prime k |	limit := max asInteger - 1.	"Fall back into #largePrimesUpTo:do: if we'd require more than 100k of memory; 	the alternative will only requre 1/154th of the amount we need here and is almost as fast."	limit > 25000 ifTrue:[^self largePrimesUpTo: max do: aBlock].	flags := (Array new: limit) atAllPut: true.	1 to: limit - 1 do: [:i |		(flags at: i) ifTrue: [			prime := i + 1.			k := i + prime.			[k <= limit] whileTrue: [				flags at: k put: false.				k := k + prime].			aBlock value: prime]].! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:33'!verbosePrimesUpTo: max	"Integer verbosePrimesUpTo: SmallInteger maxVal" "<- heh, heh"	"Compute primes up to max, but be verbose about it"	^Array streamContents:[:s| self verbosePrimesUpTo: max do:[:prime| s nextPut: prime]].! !!Integer class methodsFor: 'prime numbers' stamp: 'nice 12/27/2009 03:11'!verbosePrimesUpTo: max do: aBlock	"Integer verbosePrimesUpTo: SmallInteger maxVal" "<- heh, heh"	"Compute primes up to max, but be verbose about it"	| lastTime |	lastTime := Time millisecondClockValue.	Utilities informUserDuring:[:bar|		bar value:'Computing primes...'.		self primesUpTo: max do:[:prime| | nowTime |			aBlock value: prime.			nowTime := Time millisecondClockValue.			(nowTime - lastTime > 1000) ifTrue:[				lastTime := nowTime.				bar value:'Last prime found: ', prime printString]]].! !!Integer class methodsFor: 'class initialization' stamp: 'ar 11/30/2009 22:01'!initialize	"Integer initialize"	"Ensure we have the right compact class index"	"LPI has been a compact class forever - just ensure basic correctness"	(LargePositiveInteger indexIfCompact = 5) ifFalse:[		(Smalltalk compactClassesArray at: 5)			ifNil:[LargePositiveInteger becomeCompactSimplyAt: 5]			ifNotNil:[self error: 'Unexpected compact class setup']].	"Cog requires LNI to be compact at 4 (replacing PseudoContext)"	(LargeNegativeInteger indexIfCompact = 4) ifFalse:[		"PseudoContext will likely get removed at some point so write this test		without introducing a hard dependency"		(Smalltalk compactClassesArray at: 4) name == #PseudoContext			ifTrue:[Smalltalk compactClassesArray at: 4 put: nil].		(Smalltalk compactClassesArray at: 4)			ifNil:[LargeNegativeInteger becomeCompactSimplyAt: 4]			ifNotNil:[self error: 'Unexpected compact class setup']].! !Integer initialize!